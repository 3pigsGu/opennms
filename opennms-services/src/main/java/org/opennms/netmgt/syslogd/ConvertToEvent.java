//
// This file is part of the OpenNMS(R) Application.
//
// OpenNMS(R) is Copyright (C) 2002-2003 The OpenNMS Group, Inc.  All rights reserved.
// OpenNMS(R) is a derivative work, containing both original code, included code and modified
// code that was published under the GNU General Public License. Copyrights for modified 
// and included code are below.
//
// OpenNMS(R) is a registered trademark of The OpenNMS Group, Inc.
//
// Modifications:
//
// 2003 Jan 31: Cleaned up some unused imports.
//
// Original code base Copyright (C) 1999-2001 Oculan Corp.  All rights reserved.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 2 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.                                                            
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
//       
// For more information contact: 
//      OpenNMS Licensing       <license@opennms.org>
//      http://www.opennms.org/
//      http://www.opennms.com/
//

package org.opennms.netmgt.syslogd;

import java.io.StringReader;
import java.io.UnsupportedEncodingException;
import java.net.DatagramPacket;
import java.net.InetAddress;
import java.net.UnknownHostException;
import java.util.ArrayList;
import java.util.Date;
import java.util.List;

import org.apache.log4j.Category;
import org.exolab.castor.xml.MarshalException;
import org.exolab.castor.xml.Unmarshaller;
import org.exolab.castor.xml.ValidationException;
import org.opennms.core.utils.AlphaNumeric;
import org.opennms.core.utils.ThreadCategory;
import org.opennms.netmgt.xml.event.Event;
import org.opennms.netmgt.xml.event.Log;
import org.opennms.netmgt.xml.event.Logmsg;
import org.opennms.netmgt.xml.event.Parm;
import org.opennms.netmgt.xml.event.Parms;
import org.opennms.netmgt.xml.event.Value;
import org.opennms.netmgt.syslogd.SyslogDefs;
import org.opennms.netmgt.syslogd.SyslogdIPMgr;

/**
 * 
 * @author <a href="mailto:weave@oculan.com">Brian Weaver </a>
 * @author <a href="http://www.oculan.com">Oculan Corporation </a>
 * 
 */

// This routine do the majority of the Syslogd's work
// Improvements most likely are to be made.

final class ConvertToEvent {
    
    static final String LOG4J_CATEGORY = "OpenNMS.Syslogd";
    

    private static String m_localAddr;

    private static String m_logPrefix;

    /**
     * The received XML event, decoded using the US-ASCII encoding.
     */
    private String m_eventXML;
    
    private static Event e;

    /**
     * The decoded event document. The classes are defined in an XSD and
     * generated by castor.
     */
    private Log m_log;

    /**
     * The internet addrress of the sending agent.
     */
    private InetAddress m_sender;

    /**
     * The port of the agent on the remote system.
     */
    private int m_port;

    /**
     * The list of event that have been acknowledged.
     */
    private List m_ackEvents;


    private Event m_event;

    /**
     * Private constructor to prevent the used of <em>new</em> except by the
     * <code>make</code> method.
     */
    private ConvertToEvent() {
        // constructor not supported
        // except through make method!
    }

    /**
     * Constructs a new event encapsulation instance based upon the information
     * passed to the method. The passed datagram data is decoded into a string
     * using the <tt>US-ASCII</tt> character encoding.
     * 
     * @param packet
     *            The datagram received from the remote agent.
     * 
     * @throws java.io.UnsupportedEncodingException
     *             Thrown if the data buffer cannot be decoded using the
     *             US-ASCII encoding.
     */
    static ConvertToEvent make(DatagramPacket packet) throws UnsupportedEncodingException {
       return make(packet.getAddress(), packet.getPort(), packet.getData(), packet.getLength());
    }



    /**
     * Constructs a new event encapsulation instance based upon the information
     * passed to the method. The passed byte array is decoded into a string
     * using the <tt>US-ASCII</tt> character encoding.
     * 
     * @param addr
     *            The remote agent's address.
     * @param port
     *            The remote agent's port
     * @param data
     *            The XML data in US-ASCII encoding.
     * @param len
     *            The length of the XML data in the buffer.
     * 
     * @throws java.io.UnsupportedEncodingException
     *             Thrown if the data buffer cannot be decoded using the
     *             US-ASCII encoding.
     */
    static ConvertToEvent make(InetAddress addr, int port, byte[] data, int len) throws UnsupportedEncodingException {
        
        ConvertToEvent e = new ConvertToEvent();
       
        e.m_sender = addr;
        e.m_port = port;
        e.m_eventXML = new String(data, 0, len, "US-ASCII");
        e.m_ackEvents = new ArrayList(16);
        e.m_log = null;
        
       
        m_logPrefix = org.opennms.netmgt.syslogd.Syslogd.LOG4J_CATEGORY;
        ThreadCategory.setPrefix(m_logPrefix);       
        ThreadCategory.setPrefix(LOG4J_CATEGORY);
        Category log = ThreadCategory.getInstance();
        
        log.debug("In the make part of UdpReceivedSyslog " + e.toString());
        
        
        
        // Build a basic event out of the syslog message
        
        Event event = new Event();
        event.setSource("syslogd");
        
        
        // Set nodeId
        
        long nodeId = SyslogdIPMgr.getNodeId(addr.toString().replaceAll("/",""));
        //log.debug("Nodeid via SyslogdIPMgr " + SyslogdIPMgr.getNodeId(addr.toString().replaceAll("/","")));
        
        if (nodeId != -1)
            event.setNodeid(nodeId);
        
        

        // Set event host
        //
        try {
            event.setHost(InetAddress.getLocalHost().getHostName());
        } catch (UnknownHostException uhE) {
            event.setHost("unresolved.host");
            log.warn("Failed to resolve local hostname", uhE);
        }
        
        
        event.setInterface(addr.toString().replaceAll("/",""));
        
        
        event.setTime(org.opennms.netmgt.EventConstants.formatToString(new java.util.Date()));
        Logmsg logmsg = new Logmsg();
        logmsg.setDest("logndisplay");
        
        String message = new String(data, 0, len, "US-ASCII");
        
        //log.debug("The parsed message... " + message );
        
        int lbIdx = message.indexOf('<');
        int rbIdx = message.indexOf('>');

        if (lbIdx < 0 || rbIdx < 0 || lbIdx >= (rbIdx - 1)) {
            log.warn("Syslogd received an unparsable message!");
        }

        int priCode = 0;
        String priStr = message.substring(lbIdx + 1, rbIdx);

        try {
            priCode = Integer.parseInt(priStr);
        } catch (NumberFormatException ex) {
            log.debug("ERROR Bad priority code '" + priStr + "'");
            
        }

        int facility = SyslogDefs.extractFacility(priCode);
        int priority = SyslogDefs.extractPriority(priCode);
        
        String priorityTxt = SyslogDefs.getPriorityName(priority);
        //event.setSeverity(priorityTxt);
        
        String facilityTxt = SyslogDefs.getFacilityName(facility);
        
        
        event.setUei("uei.opennms.org/syslogd/" +facilityTxt + "/" + priorityTxt);

        // message = message.substring(rbIdx + 1, (message.length() - 1));

        message = message.substring(rbIdx + 1, (message.length()));

        //
        // Check to see if msg looks non-standard.
        // In this case, it means that there is not a standard
        // date in the front of the message text.
        //
        boolean stdMsg = true;

        if (message.length() < 16) {
            stdMsg = false;
        } else if (message.charAt(3) != ' ' || message.charAt(6) != ' '
                || message.charAt(9) != ':' || message.charAt(12) != ':'
                || message.charAt(15) != ' ') {
            stdMsg = false;
        }

        String timestamp;

        if (!stdMsg) {
            try {
                timestamp = SyslogTimeStamp.getInstance().format(new Date());
            } catch (IllegalArgumentException ex) {
                log.debug("ERROR INTERNAL DATE ERROR!");
                timestamp = "";
            }
        } else {
            timestamp = message.substring(0, 15);
            message = message.substring(16);
        }

        lbIdx = message.indexOf('[');
        rbIdx = message.indexOf(']');
        int colonIdx = message.indexOf(':');
        int spaceIdx = message.indexOf(' ');

        int processId = 0;
        String processName = "";
        String processIdStr = "";

        if (lbIdx < (rbIdx - 1) && colonIdx == (rbIdx + 1)
                && spaceIdx == (colonIdx + 1)) {
            processName = message.substring(0, lbIdx);
            processIdStr = message.substring(lbIdx + 1, rbIdx);
            message = message.substring(colonIdx + 2);

            try {
                processId = Integer.parseInt(processIdStr);
            } catch (NumberFormatException ex) {
                log.debug("ERROR Bad process id '" + processIdStr + "'");
                processId = 0;
            }
        } else if (lbIdx < 0 && rbIdx < 0 && colonIdx > 0
                && spaceIdx == (colonIdx + 1)) {
            processName = message.substring(0, colonIdx);
            message = message.substring(colonIdx + 2);
        }
        
        //log.debug(processName +"," + processId + " " + timestamp + " " + message);
      
        
        //Using parms provides configurability.
        logmsg.setContent(message );
        event.setLogmsg(logmsg);
        
//      Add appropriate parms
        Parms eventParms = new Parms();
        Parm eventParm = null;
        Value parmValue = null;

        eventParm = new Parm();
        eventParm.setParmName("syslogmessage");
        parmValue = new Value();
        parmValue.setContent((message));
        eventParm.setValue(parmValue);
        eventParms.addParm(eventParm);
        
        eventParm = new Parm();
        eventParm.setParmName("severity");
        parmValue = new Value();
        parmValue.setContent("" + priorityTxt);
        eventParm.setValue(parmValue);
        eventParms.addParm(eventParm);
        
        eventParm = new Parm();
        eventParm.setParmName("timestamp");
        parmValue = new Value();
        parmValue.setContent(timestamp);
        eventParm.setValue(parmValue);
        eventParms.addParm(eventParm);
        
        eventParm = new Parm();
        eventParm.setParmName("process");
        parmValue = new Value();
        parmValue.setContent(processName);
        eventParm.setValue(parmValue);
        eventParms.addParm(eventParm);
        
        eventParm = new Parm();
        eventParm.setParmName("processid");
        parmValue = new Value();
        parmValue.setContent("" + processId);
        eventParm.setValue(parmValue);
        eventParms.addParm(eventParm);
        
        
        //Good thing(tm)
        event.setParms(eventParms);

        
        //log.debug("Returning from SyslogToEvent " + event.toString());
        e.m_event = event;
        return e;
    }

    /**
     * Decodes the XML package from the remote agent. If an error occurs or the
     * datagram had malformed XML then an exception is generated.
     * 
     * @return The toplevel <code>Log</code> element of the XML document.
     * 
     * @throws org.exolab.castor.xml.ValidationException
     *             Throws if the documents data does not match the defined XML
     *             Schema Definition.
     * @throws org.exolab.castor.xml.MarshalException
     *             Thrown if the XML is malformed and cannot be converted.
     */
    Log unmarshal() throws ValidationException, MarshalException {
        if (m_log == null) {
            StringReader rdr = new StringReader(this.m_eventXML);
            m_log = (Log) Unmarshaller.unmarshal(Log.class, rdr);
        }
        return m_log;
    }

    /**
     * Adds the event to the list of events acknowledged in this event XML
     * document.
     * 
     * @param e
     *            The event to acknowledge.
     */
    void ackEvent(Event e) {
        if (!m_ackEvents.contains(e))
            m_ackEvents.add(e);
    }

    /**
     * Returns the raw XML data as a string.
     */
    String getXmlData() {
        return m_eventXML;
    }

    /**
     * Returns the sender's address.
     */
    InetAddress getSender() {
        return m_sender;
    }

    /**
     * Returns the sender's port
     */
    int getPort() {
        return m_port;
    }

    /**
     * Get the acknowledged events
     */
    public List getAckedEvents() {
        return m_ackEvents;
    }
    
    public Event getEvent(){
        return m_event;
    }

    /**
     * Returns true if the instance matches the object based upon the remote
     * agent's address &amp; port. If the passed instance is from the same agent
     * then it is considered equal.
     * 
     * @param o
     *            instance of the class to compare.
     * 
     * @return Returns true if the objects are logically equal, false otherwise.
     */
    public boolean equals(Object o) {
        if (o != null && o instanceof ConvertToEvent) {
            ConvertToEvent e = (ConvertToEvent) o;
            return (this == e || (m_port == e.m_port && m_sender.equals(e.m_sender)));
        }
        return false;
    }

    /**
     * Returns the hash code of the instance. The hash code is computed by
     * taking the bitwise XOR of the port and the agent's internet address hash
     * code.
     * 
     * @return The 32-bit has code for the instance.
     */
    public int hashCode() {
        return (m_port ^ m_sender.hashCode());
    }
}
