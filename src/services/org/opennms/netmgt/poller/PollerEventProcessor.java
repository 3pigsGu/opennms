//
// This file is part of the OpenNMS(R) Application.
//
// OpenNMS(R) is Copyright (C) 2002-2003 The OpenNMS Group, Inc.  All rights reserved.
// OpenNMS(R) is a derivative work, containing both original code, included code and modified
// code that was published under the GNU General Public License. Copyrights for modified 
// and included code are below.
//
// OpenNMS(R) is a registered trademark of The OpenNMS Group, Inc.
//
// Modifications:
//
// 2004 Jan 06: Added support for SUSPEND_POLLING_SERVICE_EVENT_UEI and
// 		RESUME_POLLING_SERVICE_EVENT_UEI
// 2003 Nov 11: Merged changes from Rackspace project
// 2003 Jan 31: Cleaned up some unused imports.
//
// Original code base Copyright (C) 1999-2001 Oculan Corp.  All rights reserved.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 2 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
//
// For more information contact:
//      OpenNMS Licensing       <license@opennms.org>
//      http://www.opennms.org/
//      http://www.opennms.com/
//
// Tab Size = 8
//

package org.opennms.netmgt.poller;

import java.util.ArrayList;
import java.util.Enumeration;
import java.util.Iterator;
import java.util.List;

import org.apache.log4j.Category;
import org.opennms.core.utils.ThreadCategory;
import org.opennms.netmgt.EventConstants;
import org.opennms.netmgt.config.PollerConfig;
import org.opennms.netmgt.eventd.EventIpcManager;
import org.opennms.netmgt.eventd.EventListener;
import org.opennms.netmgt.scheduler.Scheduler;
import org.opennms.netmgt.utils.XmlrpcUtil;
import org.opennms.netmgt.xml.event.Event;
import org.opennms.netmgt.xml.event.Parm;
import org.opennms.netmgt.xml.event.Parms;
import org.opennms.netmgt.xml.event.Value;

/**
 * 
 * @author <a href="mailto:jamesz@opennms.com">James Zuo </a>
 * @author <a href="mailto:weave@oculan.com">Brian Weaver </a>
 * @author <a href="http://www.opennms.org/">OpenNMS </a>
 */
final class PollerEventProcessor implements EventListener {

    private Poller m_poller;

    /**
     * Create message selector to set to the subscription
     */
    private void createMessageSelectorAndSubscribe() {
        // Create the selector for the ueis this service is interested in
        //
        List ueiList = new ArrayList();

        // nodeGainedService
        ueiList.add(EventConstants.NODE_GAINED_SERVICE_EVENT_UEI);

        // serviceDeleted
        // deleteService
        /*
         * NOTE: deleteService is only generated by the PollableService itself.
         * Therefore, we ignore it. If future implementations allow other
         * subsystems to generate this event, we may have to listen for it as
         * well. 'serviceDeleted' is the response event that the outage manager
         * generates. We ignore this as well, since the PollableService has
         * already taken action at the time it generated 'deleteService'
         */
        ueiList.add(EventConstants.SERVICE_DELETED_EVENT_UEI);
        // ueiList.add(EventConstants.DELETE_SERVICE_EVENT_UEI);

        // serviceManaged
        // serviceUnmanaged
        // interfaceManaged
        // interfaceUnmanaged
        /*
         * NOTE: These are all ignored because the responsibility is currently
         * on the class generating the event to restart the poller service. If
         * that implementation is ever changed, this message selector should
         * listen for these and act on them.
         */
        // ueiList.add(EventConstants.SERVICE_MANAGED_EVENT_UEI);
        // ueiList.add(EventConstants.SERVICE_UNMANAGED_EVENT_UEI);
        // ueiList.add(EventConstants.INTERFACE_MANAGED_EVENT_UEI);
        // ueiList.add(EventConstants.INTERFACE_UNMANAGED_EVENT_UEI);
        // interfaceIndexChanged
        // NOTE: No longer interested in this event...if Capsd detects
        // that in interface's index has changed a
        // 'reinitializePrimarySnmpInterface' event is generated.
        // ueiList.add(EventConstants.INTERFACE_INDEX_CHANGED_EVENT_UEI);
        // interfaceReparented
        ueiList.add(EventConstants.INTERFACE_REPARENTED_EVENT_UEI);

        // reloadPollerConfig
        /*
         * NOTE: This is ignored because the reload is handled through an
         * autoaction.
         */
        // ueiList.add(EventConstants.RELOAD_POLLER_CONFIG_EVENT_UEI);
        // NODE OUTAGE RELATED EVENTS
        // 
        // nodeAdded
        /*
         * NOTE: This is ignored. The real trigger will be the first
         * nodeGainedService event, at which time the interface and node will be
         * created
         */
        // ueiList.add(EventConstants.NODE_ADDED_EVENT_UEI);
        // nodeDeleted
        ueiList.add(EventConstants.NODE_DELETED_EVENT_UEI);

        // duplicateNodeDeleted
        ueiList.add(EventConstants.DUP_NODE_DELETED_EVENT_UEI);

        // nodeGainedInterface
        /*
         * NOTE: This is ignored. The real trigger will be the first
         * nodeGainedService event, at which time the interface and node will be
         * created
         */
        // ueiList.add(EventConstants.NODE_GAINED_INTERFACE_EVENT_UEI);
        // interfaceDeleted
        ueiList.add(EventConstants.INTERFACE_DELETED_EVENT_UEI);

        // suspendPollingService
        ueiList.add(EventConstants.SUSPEND_POLLING_SERVICE_EVENT_UEI);

        // resumePollingService
        ueiList.add(EventConstants.RESUME_POLLING_SERVICE_EVENT_UEI);

        // Subscribe to eventd
        getEventManager().addEventListener(this, ueiList);
    }

    /**
     * Process the event, construct a new PollableService object representing
     * the node/interface/service/pkg combination, and schedule the service for
     * polling.
     * 
     * If any errors occur scheduling the interface no error is returned.
     * 
     * @param event
     *            The event to process.
     * 
     */
    private void nodeGainedServiceHandler(Event event) {
        Category log = ThreadCategory.getInstance(getClass());

        // Is this the result of a resumePollingService event?
        String whichEvent = "Unexpected Event: " + event.getUei() + ": ";
        if (event.getUei().equals(EventConstants.NODE_GAINED_SERVICE_EVENT_UEI)) {
            whichEvent = "nodeGainedService: ";
        } else if (event.getUei().equals(EventConstants.RESUME_POLLING_SERVICE_EVENT_UEI)) {
            whichEvent = "resumePollingService: ";
        }

        // First make sure the service gained is in active state before trying
        // to
        // schedule

        String ipAddr = event.getInterface();
        int nodeid = (int) event.getNodeid();
        String svcName = event.getService();

        if (!getPoller().getQueryMgr().activeServiceExists(whichEvent, nodeid, ipAddr, svcName)) {
            if (log.isDebugEnabled()) {
                log.debug(whichEvent + nodeid + "/" + ipAddr + "/" + svcName + " not active - hence not scheduled");
            }
            return;
        }

        getPoller().scheduleService(nodeid, ipAddr, svcName);
    }

    /**
     * This method is responsible for processing 'interfacReparented' events. An
     * 'interfaceReparented' event will have old and new nodeId parms associated
     * with it. Node outage processing hierarchy will be updated to reflect the
     * new associations.
     * 
     * @param event
     *            The event to process.
     * 
     */
    private void interfaceReparentedHandler(Event event) {
        Category log = ThreadCategory.getInstance(getClass());
        if (log.isDebugEnabled())
            log.debug("interfaceReparentedHandler:  processing interfaceReparented event for " + event.getInterface());

        // Verify that the event has an interface associated with it
        if (event.getInterface() == null)
            return;

        // Extract the old and new nodeId's from the event parms
        String oldNodeIdStr = null;
        String newNodeIdStr = null;
        Parms parms = event.getParms();
        if (parms != null) {
            String parmName = null;
            Value parmValue = null;
            String parmContent = null;

            Enumeration parmEnum = parms.enumerateParm();
            while (parmEnum.hasMoreElements()) {
                Parm parm = (Parm) parmEnum.nextElement();
                parmName = parm.getParmName();
                parmValue = parm.getValue();
                if (parmValue == null)
                    continue;
                else
                    parmContent = parmValue.getContent();

                // old nodeid
                if (parmName.equals(EventConstants.PARM_OLD_NODEID)) {
                    oldNodeIdStr = parmContent;
                }

                // new nodeid
                else if (parmName.equals(EventConstants.PARM_NEW_NODEID)) {
                    newNodeIdStr = parmContent;
                }
            }
        }

        // Only proceed provided we have both an old and a new nodeId
        //
        if (oldNodeIdStr == null || newNodeIdStr == null) {
            log.error("interfaceReparentedHandler: old and new nodeId parms are required, unable to process.");
            return;
        }

        // Update node outage processing hierarchy based on this reparenting
        // event. Must "move" the interface from the "old" PollableNode object
        // to the "new" PollableNode object as identified by the old and new
        // nodeid parms.
        // 	
        // In order to perform this "move" a node lock must be obtained on both
        // PollableNode objects.
        //

        // Retrieve old and new PollableNode objects from the Poller's pollable
        // node map.
        PollableNode oldPNode = null;
        PollableNode newPNode = null;
        try {
            oldPNode = getPoller().findNode(Integer.parseInt(oldNodeIdStr));
            newPNode = getPoller().findNode(Integer.parseInt(newNodeIdStr));
        } catch (NumberFormatException nfe) {
            log.error("interfaceReparentedHandler: failed converting old/new nodeid parm to integer, unable to process.");
            return;
        }

        // Sanity check, make certain we've were able to obtain both
        // PollableNode objects.
        //
        if (oldPNode == null || newPNode == null) {
            log.error("interfaceReparentedHandler: old or new nodeId doesn't exist, unable to process.");
            return;
        }

        // Obtain node lock on both pollable node objects and then move the
        // interface from the old node to the new node.
        //
        boolean ownOldLock = false;
        boolean ownNewLock = false;

        try {
            // FIXME: Deadlock potential below.... two locks in arbitrary order
            // Obtain lock on old nodeId...wait indefinitely
            log.debug("interfaceReparentedHandler: requesting node lock for old nodeId " + oldPNode.getNodeId());
            ownOldLock = oldPNode.getNodeLock(NodeLocker.WAIT_FOREVER);
            PollableInterface pIf = oldPNode.findInterface(event.getInterface());
            log.debug("interfaceReparentedHandler: old node lock obtained, removing interface...");
            oldPNode.removeInterface(pIf);

            // Obtain lock on new nodeId...wait indefinitely
            log.debug("interfaceReparentedHandler: requesting node lock for new nodeId " + newPNode.getNodeId());
            ownNewLock = newPNode.getNodeLock(NodeLocker.WAIT_FOREVER);
            log.debug("interfaceReparentedHandler: new node lock obtained, adding interface...");
            newPNode.addInterface(pIf);

            pIf.setNode(newPNode);
            
            oldPNode.generateEvents();
            newPNode.generateEvents();
            
        } catch (InterruptedException iE) {
            log.error("interfaceReparentedHandler: thread interrupted...failed to obtain required node locks");
            return;
        } finally {
            if (ownOldLock) {
                try {
                    oldPNode.releaseNodeLock();
                } catch (InterruptedException iE) {
                    log.error("interfaceReparentedHandler: thread interrupted...failed to release old node lock on nodeid " + oldPNode.getNodeId());
                }
            }

            if (ownNewLock) {
                try {
                    newPNode.releaseNodeLock();
                } catch (InterruptedException iE) {
                    log.error("interfaceReparentedHandler: thread interrupted...failed to release new node lock on nodeid " + newPNode.getNodeId());
                }
            }
        }
    }

    /**
     * This method is responsible for removing a node's pollable service from
     * the pollable services list
     */
    private void nodeRemovePollableServiceHandler(Event event) {
        Category log = ThreadCategory.getInstance(getClass());

        int nodeId = (int) event.getNodeid();
        String intfc = event.getInterface();
        String svc = event.getService();

        final PollableNode pNode = getPoller().findNode(nodeId);
        if (pNode == null) // Sanity check
        {
            log.error("Nodeid " + nodeId + " does not exist in pollable node map, unable to remove service from pollable services list.");
            return;
        }

        PollableInterface pInterface = pNode.findInterface(event.getInterface());
        if (pInterface == null) // Sanity check
        {
            log.error("Interface " + intfc + "on node " + nodeId + " does not exist in pollable node map, unable to remove service from pollable services list.");
            return;
        }

        final PollableService pService = pInterface.findService(event.getService());
        if (pService == null) // Sanity check
        {
            log.error("Service " + svc + "on Interface " + intfc + "on node " + nodeId + " does not exist in pollable node map, unable to remove service from pollable services list.");
            return;
        }

        NodeLocker locker = new NodeLocker(pNode, "nodeRemovePollableServiceHandler") {
            protected void process() {
                Category log = ThreadCategory.getInstance(getClass());
                pService.markAsDeleted();
                if (log.isDebugEnabled())
                    log.debug("nodeRemovePollableServiceHandler: Marking service " + pService.getServiceName() + " for deletion from active polling on node " + pNode.getNodeId());
            }
        };
        locker.lockAndProcess();
    }

    /**
     * This method is responsible for removing the node specified in the
     * nodeDeleted event from the Poller's pollable node map.
     */
    private void nodeDeletedHandler(Event event) {
        Category log = ThreadCategory.getInstance(getClass());

        int nodeId = (int) event.getNodeid();
        final String sourceUei = event.getUei();

        // Extract node label and transaction No. from the event parms
        long txNo = -1L;
        Parms parms = event.getParms();
        if (parms != null) {
            String parmName = null;
            Value parmValue = null;
            String parmContent = null;

            Enumeration parmEnum = parms.enumerateParm();
            while (parmEnum.hasMoreElements()) {
                Parm parm = (Parm) parmEnum.nextElement();
                parmName = parm.getParmName();
                parmValue = parm.getValue();
                if (parmValue == null)
                    continue;
                else
                    parmContent = parmValue.getContent();

                // get the external transaction number
                if (parmName.equals(EventConstants.PARM_TRANSACTION_NO)) {
                    String temp = parmContent;
                    if (log.isDebugEnabled())
                        log.debug("nodeDeletedHandler:  parmName: " + parmName + " /parmContent: " + parmContent);
                    try {
                        txNo = Long.valueOf(temp).longValue();
                    } catch (NumberFormatException nfe) {
                        log.warn("nodeDeletedHandler: Parameter " + EventConstants.PARM_TRANSACTION_NO + " cannot be non-numberic", nfe);
                        txNo = -1;
                    }
                }
            }
        }

        final PollableNode pNode = getPoller().findNode(nodeId);
        if (pNode == null) // Sanity check
        {
            log.error("Nodeid " + nodeId + " does not exist in pollable node map, unable to delete node.");
            if (isXmlRPCEnabled()) {
                int status = EventConstants.XMLRPC_NOTIFY_FAILURE;
                XmlrpcUtil.createAndSendXmlrpcNotificationEvent(txNo, sourceUei, "Node does not exist in pollable node map.", status, "OpenNMS.Poller");
            }
            return;
        }

        
        final long transNum = txNo;
        NodeLocker locker = new NodeLocker(pNode, "nodeDeletedHandler") {
            protected void process() {
                deleteNode(pNode);
            }
            protected void handleLockFailed() {
                if (isXmlRPCEnabled()) {
                    int status = EventConstants.XMLRPC_NOTIFY_FAILURE;
                    XmlrpcUtil.createAndSendXmlrpcNotificationEvent(transNum, sourceUei, "Internal error.", status, "OpenNMS.Poller");
                }
            }
            protected void handleException(Throwable t) {
                if (isXmlRPCEnabled()) {
                    int status = EventConstants.XMLRPC_NOTIFY_FAILURE;
                    XmlrpcUtil.createAndSendXmlrpcNotificationEvent(transNum, sourceUei, t.getMessage(), status, "OpenNMS.Poller");
                }
                
            }
        };
        locker.lockAndProcess();
    }

    private void deleteNode(PollableNode pNode) {
        Category log = ThreadCategory.getInstance(getClass());
        int nodeId = pNode.getNodeId();
        // Remove the node from the Poller's node map
        getPoller().removeNode(nodeId);

        // Iterate over the node's interfaces and delete
        // all services on each interface.
        Iterator iter = pNode.getInterfaces().iterator();
        while (iter.hasNext()) {
            PollableInterface pIf = (PollableInterface) iter.next();

            // Iterate over the interface's services and mark
            // them for deletion.
            Iterator svc_iter = pIf.getServices().iterator();
            while (svc_iter.hasNext()) {
                PollableService pSvc = (PollableService) svc_iter.next();
                pSvc.markAsDeleted();

                // Now remove the service from the pollable services
                // list
                getPollableServices().remove(pSvc);
            }

            // Delete all entries from the interface's internal service
            // map
            pIf.deleteAllServices();
        }

        // Delete all entries from the node's internal interface map
        pNode.deleteAllInterfaces();

        // Mark the node as deleted to prevent any further node
        // outage processing on this node
        pNode.markAsDeleted();

        if (log.isDebugEnabled())
            log.debug("nodeDeletedHandler: deletion of nodeid " + pNode.getNodeId() + " completed.");
    }

    /**
     * 
     */
    private void interfaceDeletedHandler(Event event) {
        Category log = ThreadCategory.getInstance(getClass());

        int nodeId = (int) event.getNodeid();
        String sourceUei = event.getUei();

        // Extract node label and transaction No. from the event parms
        long txNo = -1L;
        Parms parms = event.getParms();
        if (parms != null) {
            String parmName = null;
            Value parmValue = null;
            String parmContent = null;
            Enumeration parmEnum = parms.enumerateParm();
            while (parmEnum.hasMoreElements()) {
                Parm parm = (Parm) parmEnum.nextElement();
                parmName = parm.getParmName();
                parmValue = parm.getValue();
                if (parmValue == null)
                    continue;
                else
                    parmContent = parmValue.getContent();

                // get the external transaction number
                if (parmName.equals(EventConstants.PARM_TRANSACTION_NO)) {
                    String temp = parmContent;
                    if (log.isDebugEnabled())
                        log.debug("interfaceDeletedHandlerHandler:  parmName: " + parmName + " /parmContent: " + parmContent);
                    try {
                        txNo = Long.valueOf(temp).longValue();
                    } catch (NumberFormatException nfe) {
                        log.warn("interfaceDeletedHandlerHandler: Parameter " + EventConstants.PARM_TRANSACTION_NO + " cannot be non-numberic", nfe);
                        txNo = -1;
                    }
                }
            }
        }

        PollableNode pNode = getPoller().findNode(nodeId);
        if (pNode == null) // Sanity check
        {
            log.error("Nodeid " + nodeId + " does not exist in pollable node map, unable to delete interface " + event.getInterface());

            if (isXmlRPCEnabled()) {
                int status = EventConstants.XMLRPC_NOTIFY_FAILURE;
                XmlrpcUtil.createAndSendXmlrpcNotificationEvent(txNo, sourceUei, "Node does not exist.", status, "OpenNMS.Poller");
            }
            return;
        }

        // acquire lock to 'PollableNode'
        //
        boolean ownLock = false;
        try {
            // Attempt to obtain node lock...wait as long as it takes.
            // 
            if (log.isDebugEnabled())
                log.debug("interfaceDeletedHandler: deleting nodeid/interface: " + nodeId + "/" + event.getInterface());

            ownLock = pNode.getNodeLock(NodeLocker.WAIT_FOREVER);
            if (ownLock) {
                if (log.isDebugEnabled())
                    log.debug("interfaceDeletedHandler: obtained node lock for nodeid: " + nodeId);

                // Retrieve the PollableInterface object corresponding to
                // the interface address specified in the event
                PollableInterface pIf = pNode.findInterface(event.getInterface());
                if (pIf == null) {
                    if (log.isDebugEnabled())
                        log.debug("interfaceDeletedHandler: interface " + event.getInterface() + " not in interface map for " + nodeId);
                    if (isXmlRPCEnabled()) {
                        int status = EventConstants.XMLRPC_NOTIFY_FAILURE;
                        String message = "Interface " + event.getInterface() + " not in interface map for " + nodeId;
                        XmlrpcUtil.createAndSendXmlrpcNotificationEvent(txNo, sourceUei, message, status, "OpenNMS.Poller");
                    }
                    return;
                }

                // Iterate over the interface's services and mark
                // them for deletion.
                //
                // NOTE: This is probably overkill because by the time
                // the Outage Mgr generates the interfaceDeleted
                // event all of the interface's underlying
                // services have already been deleted...but just
                // to be safe...
                Iterator svc_iter = pIf.getServices().iterator();
                while (svc_iter.hasNext()) {
                    PollableService pSvc = (PollableService) svc_iter.next();
                    pSvc.markAsDeleted();

                    // Now remove the service from the pollable services list
                    getPollableServices().remove(pSvc);
                }

                // Delete all entries from the interface's internal service map
                pIf.deleteAllServices();

                // Delete the interface from the node
                pNode.removeInterface(pIf);

                // Recalculate node status
                pNode.recalculateStatus();

                // Debug dump pollable node content
                //
                if (log.isDebugEnabled()) {
                    log.debug("Interface deletion completed, dumping node info for nodeid " + pNode.getNodeId() + ", status=" + pNode.getStatus());
                    Iterator k = pNode.getInterfaces().iterator();
                    while (k.hasNext()) {
                        PollableInterface tmpIf = (PollableInterface) k.next();
                        log.debug("		interface=" + tmpIf.getAddress().getHostAddress() + " status=" + tmpIf.getStatus());

                        Iterator s = tmpIf.getServices().iterator();
                        while (s.hasNext()) {
                            PollableService tmpSvc = (PollableService) s.next();
                            log.debug("			service=" + tmpSvc.getServiceName() + " status=" + tmpSvc.getStatus());
                        }
                    }
                }
            } else {
                // failed to acquire lock
                log.error("interfaceDeletedHandler: failed to obtain lock on nodeId " + nodeId);
                if (isXmlRPCEnabled()) {
                    int status = EventConstants.XMLRPC_NOTIFY_FAILURE;
                    String message = new String("Internal error.");
                    XmlrpcUtil.createAndSendXmlrpcNotificationEvent(txNo, sourceUei, message, status, "OpenNMS.Poller");
                }
            }
        } catch (InterruptedException iE) {
            // failed to acquire lock,
            log.error("interfaceDeletedHandler: thread interrupted...failed to obtain lock on nodeId " + nodeId);
            if (isXmlRPCEnabled()) {
                int status = EventConstants.XMLRPC_NOTIFY_FAILURE;
                XmlrpcUtil.createAndSendXmlrpcNotificationEvent(txNo, sourceUei, iE.getMessage(), status, "OpenNMS.Poller");
            }
        } catch (Throwable t) {
            log.error("exception caught processing interfaceDeleted event for " + nodeId + "/" + event.getInterface(), t);
            if (isXmlRPCEnabled()) {
                int status = EventConstants.XMLRPC_NOTIFY_FAILURE;
                XmlrpcUtil.createAndSendXmlrpcNotificationEvent(txNo, sourceUei, "Caught unknown exception.", status, "OpenNMS.Poller");
            }
        } finally {
            if (ownLock) {
                if (log.isDebugEnabled())
                    log.debug("interfaceDeletedHandler: releasing node lock for nodeid: " + nodeId);

                try {
                    pNode.releaseNodeLock();
                } catch (InterruptedException iE) {
                    log.error("interfaceDeletedHandler: thread interrupted...failed to release lock on nodeId " + nodeId);
                    if (isXmlRPCEnabled()) {
                        int status = EventConstants.XMLRPC_NOTIFY_FAILURE;
                        XmlrpcUtil.createAndSendXmlrpcNotificationEvent(txNo, sourceUei, iE.getMessage(), status, "OpenNMS.Poller");
                    }
                }
            }
        }
    }

    /**
     * <p>
     * This method remove a deleted service from the pollable service list of
     * the specified interface, so that it will not be scheduled by the poller.
     * </p>
     */
    private void serviceDeletedHandler(Event event) {
        Category log = ThreadCategory.getInstance(getClass());

        int nodeId = (int) event.getNodeid();
        String ipAddr = event.getInterface();
        String service = event.getService();

        PollableNode pNode = getPoller().findNode(nodeId);
        if (pNode == null) // Sanity check
        {
            log.error("Nodeid " + nodeId + " does not exist in pollable node map, " + "unable to delete service " + event.getService());

            return;
        }

        // acquire lock to 'PollableNode'
        //
        boolean ownLock = false;
        try {
            // Attempt to obtain node lock...wait as long as it takes.
            // 
            if (log.isDebugEnabled())
                log.debug("serviceDeletedHandler: deleting nodeid/interface/service: " + nodeId + "/" + ipAddr + "/" + service);

            ownLock = pNode.getNodeLock(NodeLocker.WAIT_FOREVER);
            if (ownLock) {
                if (log.isDebugEnabled())
                    log.debug("serviceDeletedHandler: obtained node lock for nodeid: " + nodeId);

                // Retrieve the PollableInterface object corresponding to
                // the interface address specified in the event
                PollableInterface pIf = pNode.findInterface(ipAddr);
                if (pIf == null) {
                    if (log.isDebugEnabled())
                        log.debug("serviceDeletedHandler: interface " + ipAddr + " not in interface map for " + nodeId);
                    return;
                }

                // Iterate over the interface's services and find the service
                // to delete and mark it for deletion.
                //
                Iterator svc_iter = pIf.getServices().iterator();
                while (svc_iter.hasNext()) {
                    PollableService pSvc = (PollableService) svc_iter.next();
                    if (pSvc.getServiceName().equals(service)) {
                        pSvc.markAsDeleted();

                        // Now remove the service from the pollable services
                        // list
                        getPollableServices().remove(pSvc);

                        // remove the service from the interface's internal
                        // service map
                        pIf.removeService(pSvc);
                        break;
                    }
                }

                // Recalculate interface status
                pIf.recalculateStatus();

                // Debug dump pollable node content
                //
                if (log.isDebugEnabled()) {
                    log.debug("Service deletion completed");
                    getPoller().getNetwork().dumpNode(pNode);
                }
            } else {
                // failed to acquire lock
                log.error("serviceDeletedHandler: failed to obtain lock on nodeId " + nodeId);
            }
        } catch (InterruptedException iE) {
            // failed to acquire lock,
            log.error("serviceDeletedHandler: thread interrupted...failed to obtain lock on nodeId " + nodeId);
        } catch (Throwable t) {
            log.error("exception caught processing interfaceDeleted event for " + nodeId + "/" + ipAddr, t);
        } finally {
            if (ownLock) {
                if (log.isDebugEnabled())
                    log.debug("serviceDeletedHandler: releasing node lock for nodeid: " + nodeId);

                try {
                    pNode.releaseNodeLock();
                } catch (InterruptedException iE) {
                    log.error("serviceDeletedHandler: thread interrupted...failed to release lock on nodeId " + nodeId);
                }
            }
        }
    }

    /**
     * Constructor
     * 
     * @param pollableServices
     *            List of all the PollableService objects scheduled for polling
     */
    PollerEventProcessor(Poller poller) {

        m_poller = poller;

        createMessageSelectorAndSubscribe();

        Category log = ThreadCategory.getInstance(getClass());
        if (log.isDebugEnabled())
            log.debug("Subscribed to eventd");

    }

    /**
     * Unsubscribe from eventd
     */
    public void close() {
        getEventManager().removeEventListener(this);
    }

    /**
     * @return
     */
    private EventIpcManager getEventManager() {
        return getPoller().getEventManager();
    }

    /**
     * This method is invoked by the EventIpcManager when a new event is
     * available for processing. Each message is examined for its Universal
     * Event Identifier and the appropriate action is taking based on each UEI.
     * 
     * @param event
     *            The event
     */
    public void onEvent(Event event) {
        if (event == null)
            return;

        Category log = ThreadCategory.getInstance(getClass());

        // print out the uei
        //
        if (log.isDebugEnabled()) {
            log.debug("PollerEventProcessor: received event, uei = " + event.getUei());
        }

        // If the event doesn't have a nodeId it can't be processed.
        if (!event.hasNodeid()) {
            log.info("PollerEventProcessor: no database node id found, discarding event");
        } else if (event.getUei().equals(EventConstants.NODE_GAINED_SERVICE_EVENT_UEI)) {
            // If there is no interface then it cannot be processed
            //
            if (event.getInterface() == null || event.getInterface().length() == 0) {
                log.info("PollerEventProcessor: no interface found, discarding event");
            } else {
                nodeGainedServiceHandler(event);
            }
        } else if (event.getUei().equals(EventConstants.RESUME_POLLING_SERVICE_EVENT_UEI)) {
            // If there is no interface then it cannot be processed
            //
            if (event.getInterface() == null || event.getInterface().length() == 0) {
                log.info("PollerEventProcessor: no interface found, cannot resume polling service, discarding event");
            } else {
                nodeGainedServiceHandler(event);
            }
        } else if (event.getUei().equals(EventConstants.SUSPEND_POLLING_SERVICE_EVENT_UEI)) {
            // If there is no interface then it cannot be processed
            //
            if (event.getInterface() == null || event.getInterface().length() == 0) {
                log.info("PollerEventProcessor: no interface found, cannot suspend polling service, discarding event");
            } else {
                nodeRemovePollableServiceHandler(event);
            }
        } else if (event.getUei().equals(EventConstants.INTERFACE_REPARENTED_EVENT_UEI)) {
            // If there is no interface then it cannot be processed
            //
            if (event.getInterface() == null || event.getInterface().length() == 0) {
                log.info("PollerEventProcessor: no interface found, discarding event");
            } else {
                interfaceReparentedHandler(event);
            }
        } else if (event.getUei().equals(EventConstants.NODE_DELETED_EVENT_UEI) || event.getUei().equals(EventConstants.DUP_NODE_DELETED_EVENT_UEI)) {
            if (event.getNodeid() < 0) {
                log.info("PollerEventProcessor: no node or interface found, discarding event");
            }
            // NEW NODE OUTAGE EVENTS
            nodeDeletedHandler(event);
        } else if (event.getUei().equals(EventConstants.INTERFACE_DELETED_EVENT_UEI)) {
            // If there is no interface then it cannot be processed
            //
            if (event.getNodeid() < 0 || event.getInterface() == null || event.getInterface().length() == 0) {
                log.info("PollerEventProcessor: invalid nodeid or no interface found, discarding event");
            } else {
                interfaceDeletedHandler(event);
            }
        } else if (event.getUei().equals(EventConstants.SERVICE_DELETED_EVENT_UEI)) {
            // If there is no interface then it cannot be processed
            //
            if ((event.getNodeid() < 0) || (event.getInterface() == null) || (event.getInterface().length() == 0) || (event.getService() == null)) {
                log.info("PollerEventProcessor: invalid nodeid or no nodeinterface " + "or service found, discarding event");
            } else {
                serviceDeletedHandler(event);
            }

        } // end single event proces

    } // end onEvent()

    /**
     * Return an id for this event listener
     */
    public String getName() {
        return "Poller:PollerEventProcessor";
    }

    /**
     * @return
     */
    private Poller getPoller() {
        return m_poller;
    }

    /**
     * @return
     */
    private PollerConfig getPollerConfig() {
        return getPoller().getPollerConfig();
    }

    /**
     * @return Returns the scheduler.
     */
    private Scheduler getScheduler() {
        return getPoller().getScheduler();
    }

    /**
     * @return Returns the xmlrpc.
     */
    private boolean isXmlRPCEnabled() {
        return getPollerConfig().getXmlrpc();
    }

    /**
     * @return Returns the pollableServices.
     */
    private List getPollableServices() {
        return getPoller().getPollableServiceList();
    }
} // end class
