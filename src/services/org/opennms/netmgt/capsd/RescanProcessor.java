//
// Copyright (C) 2002 Sortova Consulting Group, Inc.  All rights reserved.
// Parts Copyright (C) 1999-2001 Oculan Corp.  All rights reserved.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 2 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
//
// For more information contact:
//      OpenNMS Licensing       <license@opennms.org>
//      http://www.opennms.org/
//      http://www.sortova.com/
//
//
// Tab Size = 8
//
package org.opennms.netmgt.capsd;

import java.lang.*;

import java.net.InetAddress;
import java.net.UnknownHostException;

import java.sql.SQLException;
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;

import java.util.Map;
import java.util.HashMap;
import java.util.List;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Set;
import java.util.Iterator;
import java.util.Date;

import org.apache.log4j.Category;
import org.opennms.core.utils.ThreadCategory;

import org.opennms.netmgt.EventConstants;
import org.opennms.netmgt.eventd.EventIpcManagerFactory;
import org.opennms.netmgt.capsd.snmp.*;
import org.opennms.protocols.snmp.*;

import org.opennms.netmgt.config.DatabaseConnectionFactory;
import org.opennms.netmgt.config.CapsdConfigFactory;
import org.opennms.netmgt.config.PollerConfigFactory;
import org.opennms.netmgt.config.CollectdConfigFactory;

// These generated by castor
//
import org.opennms.netmgt.xml.event.Event;
import org.opennms.netmgt.xml.event.Parm;
import org.opennms.netmgt.xml.event.Value;
import org.opennms.netmgt.xml.event.Parms;

// castor classes generated from the discovery-configuration.xsd
import org.opennms.netmgt.config.capsd.*;

/**
 * This class is designed to rescan all the managed interfaces for a
 * specified node, update the database based on the information collected, 
 * and generate events necessary to notify the other OpenNMS services.  
 * The constructor takes an integer which is the node identifier of the 
 * node to be rescanned.
 *.
 * @author <a href="mailto:jamesz@opennms.org">James Zuo</a>
 * @author <a href="mailto:mike@opennms.org">Mike Davidson</a>
 * @author <a href="mailto:weave@opennms.org">Brian Weaver</a>
 * @author <a href="http://www.opennms.org/">OpenNMS</a>
 */
final class RescanProcessor
	implements Runnable
{
	/** 
	 * SQL statement for retrieving the 'nodetype' field of the node table
	 * for the specified nodeid.  Used to determine if the node is active ('A')
	 * or been marked as deleted ('D')..
	 */
	final static String	SQL_DB_RETRIEVE_NODE_TYPE = "SELECT nodetype FROM node WHERE nodeID=?";
	
	/**
	 * SQL statements used to reparent an interface and its associated
	 * services under a new parent nodeid
	 */
	final static String 	SQL_DB_REPARENT_IP_INTERFACE	= "UPDATE ipinterface SET nodeID=? WHERE nodeID=? AND ipaddr=? AND isManaged!='D'";
	final static String 	SQL_DB_REPARENT_SNMP_IF_LOOKUP	= "SELECT ipaddr FROM snmpinterface WHERE nodeID=? AND snmpifindex=?";
	final static String 	SQL_DB_REPARENT_SNMP_IF_DELETE	= "DELETE FROM snmpinterface WHERE nodeID=? AND snmpifindex=?";
	final static String 	SQL_DB_REPARENT_SNMP_INTERFACE	= "UPDATE snmpinterface SET nodeID=? WHERE nodeID=? AND snmpifindex=?";
	final static String 	SQL_DB_REPARENT_IF_SERVICES	= "UPDATE ifservices SET nodeID=? WHERE nodeID=? AND ipaddr=? AND status!='D'";
	
	private final static String 	SELECT_METHOD_MIN = "min";
	private final static String 	SELECT_METHOD_MAX = "max";

	/**
	 *  Information necessary to schedule the node.
	 */
	private Scheduler.NodeInfo	m_scheduledNode;
	
	/**
	 * Indicates if the rescan is in response to a forceRescan event.
	 */
	private boolean			m_forceRescan;
	
	/**
	 * Event list...during the rescan significant database changes
	 * cause events (interfaceReparented, nodeGainedService, etc...)
	 * to be created and added to the event list.  The last thing
	 * the rescan process does is send the events out.
	 */
	private List  			m_eventList;
	
	/**
	 * Capsd configuration factory
	 */
	private CapsdConfigFactory	m_cFactory;
	
	/** 
	  * Set during the rescan to true if any of the ifIndex values 
	  * associated with a node's interface's were modified as a 
	  * result of the scan.
	  */
	private boolean 		m_ifIndexOnNodeChangedFlag;
	
	/**
	 * Set during the rescan to true if a new interface is added 
	 * to the snmpInterfaces table or if any key fields of the node's 
	 * snmpIntefaces table were modified (such as ifIndex or ifType)
	 */
	private boolean			m_snmpIfTableChangedFlag;
	
	/**
	 * Constructor.
	 * 
	 * @param nodeInfo 	Scheduler.NodeInfo object containing the nodeid of 
	 * 			the node to be rescanned.
	 * @param forceRescan	True if a forced rescan is to be performed (all interfaces
	 * 			not just managed interfaces scanned), false otherwise.
	 */
	RescanProcessor(Scheduler.NodeInfo nodeInfo, boolean forceRescan)
	{
		// Check the arguments
		//
		if(nodeInfo == null)
			throw new IllegalArgumentException("The nodeInfo parm cannot be null!");
		
		m_scheduledNode = nodeInfo;
		m_forceRescan = forceRescan;
		
		m_eventList = new ArrayList();
	}

	/**
	 * This method is responsible for updating the node table using the most
	 * recent data collected from the node's managed interfaces.
	 *
	 * @param dbc			Database connection
	 * @param now			Date object representing the time of the rescan.
	 * @param dbNodeEntry		DbNodeEntry object representing existing values in the database
	 * @param currPrimarySnmpIf 	Primary SNMP interface address based on latest collection
	 * @param dbIpInterfaces	Array of DbIpInterfaceEntry objects representing all the
	 * 				interfaces retrieved from the database for this node.
	 * @param collectorMap		Map of IfCollector objects...one per managed interface.
	 * 
	 * @return DbNodeEntry object representing the updated values from the node table in the
	 * 			database.
	 * 
	 * @throws SQLException if there is a problem updating the node table.
	 */
	private DbNodeEntry updateNode(Connection dbc,
					Date      now,
					DbNodeEntry dbNodeEntry,
					InetAddress currPrimarySnmpIf,
					DbIpInterfaceEntry[] dbIpInterfaces,
					Map collectorMap)
		throws SQLException
	{
		Category log = ThreadCategory.getInstance(getClass());
	
		if (log.isDebugEnabled())
			log.debug("updateNode: updating node id " + dbNodeEntry.getNodeId());
		
		// Clone the existing dbNodeEntry so we have all the original
		// values of the 'node' table fields in case we need to generate
		// 'node***Changed' events following the update.
		//
		DbNodeEntry originalDbNodeEntry = DbNodeEntry.clone(dbNodeEntry);
		
		// Create node which represents the most recently retrieved 
		// information in the collector for this node
		//
		DbNodeEntry currNodeEntry = DbNodeEntry.create();
		currNodeEntry.setNodeType(DbNodeEntry.NODE_TYPE_ACTIVE);
		
		// Set node label and SMB info based on latest collection
		//
		setNodeLabelAndSmbInfo(collectorMap, dbNodeEntry, currNodeEntry, currPrimarySnmpIf);
		
		// Set SNMP info
		//
		if (currPrimarySnmpIf != null)
		{
			// We prefer to use the collector for the primary SNMP interface
			// to update SNMP data in the node table.  However a collector
			// for the primary SNMP interface may not exist in the map if
			// a node has only recently had SNMP support enabled or if the
			// new primary SNMP interface was only recently added to the
			// node.  At any rate if it exists use it, if not use the
			// first collector which supports SNMP.
			IfCollector primaryIfc = (IfCollector)collectorMap.get(currPrimarySnmpIf.getHostAddress());
			if (primaryIfc == null)
			{
				Collection collectors = collectorMap.values();
				Iterator iter = collectors.iterator();
				while (iter.hasNext())
				{
					primaryIfc = (IfCollector)iter.next();
					if (primaryIfc.getSnmpCollector() != null)
						break;
				}
			}
			
			// Sanity check...should always have a primary interface
			// collector at this point
			if (primaryIfc == null)
			{
				log.error("updateNode: failed to determine primary interface collector for node " + dbNodeEntry.getNodeId());
				throw new RuntimeException("Update node failed for node " + dbNodeEntry.getNodeId() + ", unable to determine primary interface collector.");
			}
			
			IfSnmpCollector snmpc = primaryIfc.getSnmpCollector();
			
			if (snmpc != null && snmpc.hasSystemGroup())
			{
				SystemGroup sysgrp = snmpc.getSystemGroup();

				// sysObjectId
				currNodeEntry.setSystemOID(sysgrp.get(SystemGroup.SYS_OBJECTID).toString());
				
				// sysName
				String str = SystemGroup.getPrintableString((SnmpOctetString)sysgrp.get(SystemGroup.SYS_NAME));
				if(str != null && str.length() > 0)
					currNodeEntry.setSystemName(str);
	
				// sysDescription
				str = SystemGroup.getPrintableString((SnmpOctetString) sysgrp.get(SystemGroup.SYS_DESCR));
				if (str!= null && str.length() > 0)
					currNodeEntry.setSystemDescription(str);

				// sysLocation
				str = SystemGroup.getPrintableString((SnmpOctetString) sysgrp.get(SystemGroup.SYS_LOCATION));
				if(str != null && str.length() > 0)
					currNodeEntry.setSystemLocation(str);

				// sysContact
				str = SystemGroup.getPrintableString((SnmpOctetString) sysgrp.get(SystemGroup.SYS_CONTACT));
				if(str != null && str.length() > 0)
					currNodeEntry.setSystemContact(str);
			}
		}

		// Currently, we do not use the ParentId except in mapping. Unforunately, this is never
		// set in the currNodeEntry so it gets reset here. As a workaround, setting it to the old value.

		currNodeEntry.updateParentId(dbNodeEntry.getParentId());
		
		// Update any fields which have changed
		if (log.isDebugEnabled())
		{
			log.debug("updateNode: -------dumping old node-------: " + dbNodeEntry);
			log.debug("updateNode: -------dumping new node-------: "  + currNodeEntry);
		}
		dbNodeEntry.updateParentId(currNodeEntry.getParentId());
		dbNodeEntry.updateNodeType(currNodeEntry.getNodeType());
		dbNodeEntry.updateSystemOID(currNodeEntry.getSystemOID());
		dbNodeEntry.updateSystemName(currNodeEntry.getSystemName());
		dbNodeEntry.updateSystemDescription(currNodeEntry.getSystemDescription());
		dbNodeEntry.updateSystemLocation(currNodeEntry.getSystemLocation());
		dbNodeEntry.updateSystemContact(currNodeEntry.getSystemContact());
		dbNodeEntry.updateNetBIOSName(currNodeEntry.getNetBIOSName());
		dbNodeEntry.updateDomainName(currNodeEntry.getDomainName());
		dbNodeEntry.updateOS(currNodeEntry.getOS());
		dbNodeEntry.setLastPoll(now);
		
		// Only update node label/source if original node entry is 
		// not set to user-defined.
		if (dbNodeEntry.getLabelSource() != dbNodeEntry.LABEL_SOURCE_USER)
		{
			dbNodeEntry.updateLabel(currNodeEntry.getLabel());
			dbNodeEntry.updateLabelSource(currNodeEntry.getLabelSource());
		}
		
		// Set event flags
		boolean nodeLabelChangedFlag = false;
		boolean nodeInfoChangedFlag = false;
		
		if (dbNodeEntry.hasLabelChanged() || 
			dbNodeEntry.hasLabelSourceChanged())
		{
			nodeLabelChangedFlag = true;
		}
		
		if (dbNodeEntry.hasSystemOIDChanged() ||
			dbNodeEntry.hasSystemNameChanged() ||
			dbNodeEntry.hasSystemDescriptionChanged() ||
			dbNodeEntry.hasSystemLocationChanged() ||
			dbNodeEntry.hasSystemContactChanged() ||
			dbNodeEntry.hasNetBIOSNameChanged() ||
			dbNodeEntry.hasDomainNameChanged() ||
			dbNodeEntry.hasOSChanged())
		{
			nodeInfoChangedFlag = true;
		}
		
		// Call store to update the database
		dbNodeEntry.store(dbc);
		
		// Create nodeLabelChanged event if necessary
		if (nodeLabelChangedFlag)
		{
			createNodeLabelChangedEvent(dbNodeEntry, originalDbNodeEntry);
		}
		
		// Create nodeInfoChangedEvent if necessary
		if (nodeInfoChangedFlag)
		{
			createNodeInfoChangedEvent(dbNodeEntry, originalDbNodeEntry);
		}
		
		return dbNodeEntry;
	}
	
	/**
	 * This method is responsible for updating all of the interface's associated
	 * with a node.
	 * 
	 * @param dbc 		Database connection.
	 * @param now		Date/time to be associated with the update.
	 * @param node		Node entry for the node being rescanned
	 * @param collectorMap	Map of IfCollector objects associated with the node.
	 * 
	 * @throws SQLException if there is a problem updating the ipInterface table.
	 */
	private void updateInterfaces(Connection  dbc, 
				      Date        now,
				      DbNodeEntry node,
				      Map         collectorMap)
		throws SQLException
	{
		// Reset modification flags.  These flags are set by
		// the updateInterface() method when changes have been
		// detected which warrant further action (such as 
		// generating an event).
		m_ifIndexOnNodeChangedFlag = false;
		m_snmpIfTableChangedFlag = false;
		
		// List of update interfaces
		// This list is maintained so that for nodes with multiple
		// interfaces which support SNMP, interfaces are not updated
		// more than once.  
		List updatedIfList = new ArrayList();
		
		// Determine if any of the interface collector objects have
		// an SNMP collector associated with them.  If so, use the first
		// interface with SNMP data collected to update all SNMP-found
		// interfaces.
		//
		Iterator iter = collectorMap.values().iterator();
		IfCollector collectorWithSnmp = null;
		while (iter.hasNext())
		{
			IfCollector tmp = (IfCollector)iter.next();
			if (tmp.getSnmpCollector() != null)
			{
				collectorWithSnmp = tmp;
				break;
			}
		}
		

		IfSnmpCollector snmpCollector = null;
		if (collectorWithSnmp != null)
		{
			snmpCollector = collectorWithSnmp.getSnmpCollector();
			
			updateInterface(dbc, 
					now,
					node,
					collectorWithSnmp.getTarget(),
					collectorWithSnmp.getTarget(),
					collectorWithSnmp.getSupportedProtocols(),
					snmpCollector);
			updatedIfList.add(collectorWithSnmp.getTarget());
			
			// Update subtargets
			if (collectorWithSnmp.hasAdditionalTargets())
			{
				Map subTargets = collectorWithSnmp.getAdditionalTargets();
				Iterator xiter = subTargets.keySet().iterator();
				while (xiter.hasNext())
				{
					InetAddress subIf = (InetAddress)xiter.next();
					updateInterface(dbc,
							now,
							node,
							collectorWithSnmp.getTarget(),
							subIf,
							(List)subTargets.get(subIf),
							snmpCollector);
					updatedIfList.add(subIf);
				}
			}
			
			// Add any new non-IP interfaces
			//
			if (collectorWithSnmp.hasNonIpInterfaces())
			{
				iter = ((List)collectorWithSnmp.getNonIpInterfaces()).iterator();
				while(iter.hasNext())
				{
					SnmpInt32 ifIndex = (SnmpInt32)iter.next();
						
					updateNonIpInterface(dbc, now, node, ifIndex.getValue(), snmpCollector);
				}
			}
		}
		
		// Majority of interfaces should have been updated by this 
		// point (provided the node supports SNMP).  Only non-SNMP
		// interfaces and those associated with the node via
		// SMB (NetBIOS name) should remain.  Loop through collector
		// map and update any remaining interfaces.  Use the
		// updatedIfList object to filter out any interfaces which
		// have already been updated
		
		// Iterate over interfaces from collection map
		iter = collectorMap.values().iterator();
		while (iter.hasNext())
		{
			IfCollector ifc = (IfCollector)iter.next();
			
			// Update target
			InetAddress ifaddr = ifc.getTarget();
			if (!updatedIfList.contains(ifaddr))
			{
				updateInterface(dbc,
						now,
						node,
						ifc.getTarget(),
						ifaddr,
						ifc.getSupportedProtocols(),
						snmpCollector);
				updatedIfList.add(ifaddr);
			}
			
			// Update subtargets
			if (ifc.hasAdditionalTargets())
			{
				Map subTargets = ifc.getAdditionalTargets();
				Set keys = subTargets.keySet();
				Iterator xiter = keys.iterator();
				while (xiter.hasNext())
				{
					InetAddress subIf = (InetAddress)xiter.next();
					if (!updatedIfList.contains(subIf))
					{
						updateInterface(dbc,
								now,
								node,
								ifc.getTarget(),
								subIf,
								(List)subTargets.get(subIf),
								snmpCollector);
						updatedIfList.add(subIf);
					}
				}
			}
		} // end while(more interfaces)
	}

	/**
	 * This method is responsible for updating the ipInterface table entry
	 * for a specific interface.
	 *
	 * @param dbc		Database Connection
	 * @param now		Date/time to be associated with the update.
	 * @param node		Node entry for the node being rescanned
	 * @param ifIndex 	Interface index of non-IP interface to update
	 * @param snmpc		SNMP collector or null if SNMP not supported.
	 * 
	 * @throws SQLException if there is a problem updating the ipInterface table.
	 */
	private void updateNonIpInterface(Connection  dbc,
					  Date        now,
					  DbNodeEntry node,
					  int         ifIndex,
					  IfSnmpCollector snmpc)
		throws SQLException
	{
		Category log = ThreadCategory.getInstance(getClass());
		
		if (log.isDebugEnabled())
			log.debug("updateNonIpInterface: node= " + node.getNodeId() + " ifIndex= " + ifIndex);
		
		// Sanity Check
		// 
		if (snmpc == null || snmpc.failed())
			return;
		
		// Construct InetAddress object for "0.0.0.0" address
		//
		InetAddress ifAddr = null;
		try
		{
			ifAddr = InetAddress.getByName("0.0.0.0");
		}
		catch (UnknownHostException uhE)
		{
			log.error("Failed to update non-IP interfaces, unable to construct '0.0.0.0' InetAddress", uhE);
			return;
		} 
		
		// -------------------------------------------------------------------
		// IpInterface table updates
		// -------------------------------------------------------------------
		
		// Attempt to load IP Interface entry from the database
		//
		DbIpInterfaceEntry dbIpIfEntry = DbIpInterfaceEntry.get(dbc, node.getNodeId(), ifAddr, ifIndex);
		if (dbIpIfEntry == null)
		{
			// Create a new entry
			if (log.isDebugEnabled())
				log.debug("updateNonIpInterface: non-IP interface with ifIndex " + ifIndex + " not in database, creating new interface object.");
			dbIpIfEntry = DbIpInterfaceEntry.create(node.getNodeId(), ifAddr);
		}
		
		// Update any IpInterface table fields which have changed
		//
		dbIpIfEntry.setLastPoll(now);
		dbIpIfEntry.setIfIndex(ifIndex);
		dbIpIfEntry.setManagedState(DbIpInterfaceEntry.STATE_UNMANAGED);
		int status = snmpc.getAdminStatus(ifIndex);
		if(status != -1)
			dbIpIfEntry.setStatus(status);			

		// Removed the following update to insure that the issnmpprimary field was not
		// over-written during a rescan. Since it should already be set, there is no
		// need to re-set it.

		// dbIpIfEntry.setPrimaryState(DbIpInterfaceEntry.SNMP_NOT_ELIGIBLE);
		
		// Update the database
		dbIpIfEntry.store(dbc);
		
		// -------------------------------------------------------------------
		// SnmpInterface table updates
		// -------------------------------------------------------------------
		if (log.isDebugEnabled())
			log.debug("updateNonIpInterface: updating non-IP snmp interface with nodeId=" + node.getNodeId() + " and ifIndex=" + ifIndex);
			
		// Create and load SNMP Interface entry from the database
		//
		boolean newSnmpIfTableEntry = false;
		DbSnmpInterfaceEntry dbSnmpIfEntry = DbSnmpInterfaceEntry.get(dbc, node.getNodeId(), ifIndex);
		if (dbSnmpIfEntry == null)
		{
			// SNMP Interface not found with this nodeId & ifIndex, create new interface
			if (log.isDebugEnabled())
				log.debug("updateNonIpInterface: non-IP SNMP interface with ifIndex " + ifIndex + " not in database, creating new snmpInterface object.");
			dbSnmpIfEntry = DbSnmpInterfaceEntry.create(node.getNodeId(), ifIndex);
			newSnmpIfTableEntry = true;
		}
		
		// Find the ifTable entry for this interface
		IfTable ift = snmpc.getIfTable();
		Iterator ifiter = ift.getEntries().iterator();
		IfTableEntry ifte = null;
		boolean match = false;
		while(ifiter.hasNext())
		{
			ifte = (IfTableEntry)ifiter.next();
			
			// index
			//
			SnmpInt32 sint = (SnmpInt32)ifte.get(IfTableEntry.IF_INDEX);
			if(sint != null)
			{
				if (ifIndex == sint.getValue())
				{ 
					if (log.isDebugEnabled())
						log.debug("updateNonIpInterface: found match for ifIndex: " + ifIndex);
					match = true;
					break;
				}
			}
		}
		
		// Make sure we have a valid IfTableEntry object and update
		// any values which have changed
		if (match && ifte != null)
		{
			// index
			//dbSnmpIfEntry.updateIfIndex(ifIndex);

			// ipAddress
			dbSnmpIfEntry.updateIfAddress(ifAddr);
			
			// netmask 
			//
			// NOTE: non-IP interfaces don't have netmasks so skip
			
			// type
			SnmpInt32 sint = (SnmpInt32)ifte.get(IfTableEntry.IF_TYPE);
			dbSnmpIfEntry.updateType(sint.getValue());
				
			// description
			String str = SystemGroup.getPrintableString((SnmpOctetString)ifte.get(IfTableEntry.IF_DESCR));
			if (log.isDebugEnabled())
				log.debug("updateNonIpInterface: ifIndex: " + ifIndex + " has ifDescription: " + str);
			if(str != null && str.length() > 0)
				dbSnmpIfEntry.updateDescription(str);
				
			// physical address
			StringBuffer sbuf = new StringBuffer();
			SnmpOctetString ostr = (SnmpOctetString)ifte.get(IfTableEntry.IF_PHYS_ADDR);
                        if ( ostr != null && ostr.getLength() > 0)
                        {
				byte[] bytes = ostr.getString();
				for(int i = 0; i < bytes.length; i++)
				{
					sbuf.append(Integer.toHexString(((int)bytes[i] >> 4) & 0xf));
					sbuf.append(Integer.toHexString((int)bytes[i] & 0xf));
				}
			}
			
			String physAddr = sbuf.toString().trim();
			
			if (log.isDebugEnabled())
				log.debug("updateNonIpInterface: ifIndex: " + ifIndex + " has physical address: -" + physAddr + "-");
			
			if (physAddr.length() == 12)
			{
				dbSnmpIfEntry.updatePhysicalAddress(physAddr);
			}

			// speed
			SnmpUInt32 uint = (SnmpUInt32)ifte.get(IfTableEntry.IF_SPEED);
                        if (uint == null)
                        {
                                dbSnmpIfEntry.updateSpeed(0);
                        }
                        else
                        {
                                dbSnmpIfEntry.updateSpeed((int)uint.getValue());
                        }

			// admin status
			sint = (SnmpInt32)ifte.get(IfTableEntry.IF_ADMIN_STATUS);
                        if (sint == null)
                        {
                                dbSnmpIfEntry.updateAdminStatus(0);
                        }
                        else
                        {
				dbSnmpIfEntry.updateAdminStatus(sint.getValue());
                        }

					
			// oper status
			sint = (SnmpInt32)ifte.get(IfTableEntry.IF_OPER_STATUS);
                        if (sint == null)
                        {
                                dbSnmpIfEntry.updateOperationalStatus(0);
                        }
                        else
                        {
				dbSnmpIfEntry.updateOperationalStatus(sint.getValue());
                        }

			
			// name (from interface extensions table)
			SnmpOctetString snmpIfName = snmpc.getIfName(ifIndex);
			if (snmpIfName != null)
			{
				String ifName = SystemGroup.getPrintableString(snmpIfName);
				if (ifName!= null  && ifName.length() > 0)
					dbSnmpIfEntry.updateName(ifName);
			}
				
		} // end if valid ifTable entry
			
		// If this is a new interface or if any of the following 
		// key fields have changed set the m_snmpIfTableChangedFlag 
		// variable to TRUE.  This will potentially trigger an event 
		// which will cause the poller to reinitialize the primary 
		// SNMP interface for the node.
		if (!m_snmpIfTableChangedFlag &&
			newSnmpIfTableEntry || 
			//dbSnmpIfEntry.hasIfIndexChanged() ||
			dbSnmpIfEntry.hasIfAddressChanged() ||
			dbSnmpIfEntry.hasTypeChanged() ||
			dbSnmpIfEntry.hasNameChanged() ||
			dbSnmpIfEntry.hasDescriptionChanged() ||
			dbSnmpIfEntry.hasPhysicalAddressChanged())
		{
			m_snmpIfTableChangedFlag = true;
		}
		
		// Update the database
		dbSnmpIfEntry.store(dbc);
	}
	
	/**
	 * This method is responsible for updating the ipInterface table entry
	 * for a specific interface.
	 *
	 * @param dbc		Database Connection
	 * @param now		Date/time to be associated with the update.
	 * @param node		Node entry for the node being rescanned
	 * @param target 	Target interface (from IfCollector.getTarget())
	 * @param ifaddr	Interface being updated.
	 * @param protocols	Protocols supported by the interface.
	 * @param snmpc		SNMP collector or null if SNMP not supported.
	 * 
	 * @throws SQLException if there is a problem updating the ipInterface table.
	 */
	private void updateInterface(Connection  dbc,
				     Date        now,
				     DbNodeEntry node,
				     InetAddress target,
				     InetAddress ifaddr,
				     List	 protocols,
				     IfSnmpCollector snmpc)
		throws SQLException
	{
		Category log = ThreadCategory.getInstance(getClass());
		
		CapsdConfigFactory cFactory = CapsdConfigFactory.getInstance();
		PollerConfigFactory pollerCfgFactory = PollerConfigFactory.getInstance();

		if (log.isDebugEnabled())
		{
			log.debug("updateInterface: updating interface " + ifaddr.getHostAddress() + "(targetIf=" + target.getHostAddress() + ")");
		}
				
		boolean isAlias = false;
		boolean reparentFlag = false;
		
		DbNodeEntry duplicateNodeEntry = null;
		boolean deleteDuplicateNodeFlag = false;
		boolean newIpIfEntry = false;
		
		// Attempt to load IP Interface entry from the database
		//
                int ifIndex = snmpc.getIfIndex(ifaddr);
		if (log.isDebugEnabled())
			log.debug("updateInterface: interface =" + ifaddr.getHostAddress() + " ifIndex = " + ifIndex);
                
		DbIpInterfaceEntry dbIpIfEntry = DbIpInterfaceEntry.get(dbc, node.getNodeId(), ifaddr);
                if (ifIndex != -1)
                {
		        DbIpInterfaceEntry ifEntry = DbIpInterfaceEntry.get(dbc, node.getNodeId(), ifaddr, ifIndex);
                        if ( ifEntry != null)
                                dbIpIfEntry = ifEntry;
                }
                        
		if (dbIpIfEntry == null)
		{
			//
			// Reparenting
			//
			// This sub-interface was not previously associated with this node.  If 
			// the sub-interface is already associated with another node we must do 
			// one of the following:
			//
			// 1. If the target interface (the one being rescanned) appears to be an 
			//    interface alias all of the interfaces under the sub-interface's node 
			//    will be reparented under the nodeid of the target interface.
			//
			// 2. If however the interface is not an alias, only the sub-interface will
			//    be reparented under the nodeid of the interface being rescanned.
			//
			// In the reparenting process, the database ipinterface, snmpinterface
			// and ifservices table entries associated with the reparented interface
			// will be "updated" to reflect the new nodeid.  If the old node has 
			// no remaining interfaces following the reparenting it will be marked 
			// as deleted.
			//
			
			// Special case:  Need to skip interface reparenting for '0.0.0.0' 
			// interfaces as well as loopback interfaces ('127.*.*.*').
			int oldNodeId = -1;
			if (!ifaddr.getHostAddress().equals("0.0.0.0") && 
				!ifaddr.getHostAddress().startsWith("127.")) 
			{
				oldNodeId = cFactory.getInterfaceDbNodeId(dbc, ifaddr, ifIndex);
			}
			else
			{
				if (log.isDebugEnabled())
					log.debug("updateInterface: interface " + ifaddr.getHostAddress() + " is NOT eligible for reparenting.");
			}
				
			if (oldNodeId != -1)
			{
				if (log.isDebugEnabled())
					log.debug("updateInterface: interface " + ifaddr.getHostAddress() + " is however under nodeid " + oldNodeId);

				// Determine if target interface is an alias or not?
				isAlias = isInterfaceAlias(target, snmpc); 
				if (isAlias)
				{

                                        // the target interface is not exist in the ipAddrTable of this node.
                                        // Do nothing
					if (log.isDebugEnabled())
						log.debug("updateInterface: target interface " + ifaddr.getHostAddress() + " is an alias, reparenting all interfaces from node " + oldNodeId + " to node " + node.getNodeId());
						
					// Its an alias, move all the interfaces associated with the 
					// sub-interface's nodeid under the target's nodeid
					duplicateNodeEntry = DbNodeEntry.get(dbc, oldNodeId);
					if (duplicateNodeEntry != null)
					{
						// Retrieve list of interfaces associated with the old node
						DbIpInterfaceEntry[] tmpIfArray = duplicateNodeEntry.getInterfaces(dbc);
						
						// Reparent each interface under the targets' nodeid 
						for (int i=0; i<tmpIfArray.length; i++)
						{
							InetAddress addr = tmpIfArray[i].getIfAddress();
							int index = tmpIfArray[i].getIfIndex();
							
							// Skip non-IP or loopback interfaces
							if (!addr.getHostAddress().equals("0.0.0.0") && 
								!addr.getHostAddress().startsWith("127.")) 
							{
								continue;
							}
							
							if (log.isDebugEnabled())
								log.debug("updateInterface: reparenting interface " + tmpIfArray[i].getIfAddress().getHostAddress() + " under node " + node.getNodeId());
								
							reparentInterface(dbc, addr, index, node.getNodeId(), oldNodeId);
							
							// Create interfaceReparented event
							createInterfaceReparentedEvent(node, oldNodeId, addr);
						}
					}
					
					// Set reparent flag
					reparentFlag = true;
				}
				else
				{
                                        // 
                                        // target interface is not an alias. Check if the updating interface
                                        // exists in the ipAddrTable of the oldNode. If it is not in the old 
                                        // node, reparent the interface to the new node. Otherwise, it is a
                                        // duplicate interface, and add it to the new node and create an 
                                        // interfaceAdded event and duplicateInterface event.
                                        //
					duplicateNodeEntry = DbNodeEntry.get(dbc, oldNodeId);
					if (duplicateNodeEntry != null)
        				{
                                                if (isInIpAddrTable(ifaddr, duplicateNodeEntry))
                                                {
                                                        dbIpIfEntry = addDuplicateInterface(node, ifaddr, protocols, snmpc);
		                                        // Attempt to load IP Interface entry from the database
		                                        // since dbIpIfEntry is used later in the following 
                                                        // program.
                                                        //
			                                if (dbIpIfEntry != null)
                                                        {
                                                                newIpIfEntry = true;
                					        if (log.isDebugEnabled())
                						        log.debug("updateInterface: interface " + ifaddr.getHostAddress() 
                                                                        + " is added to node: " + node.getNodeId());
                                                        }
                                                }
                                                else
                                                {
        					        // 
        					        // It is not in the ipAddrTable of the oldNodeId, issue SQL update to 
                                                        // move the sub-interface and its services under its new parent node
        					        //
        					        if (log.isDebugEnabled())
                						log.debug("updateInterface: target interface " 
                                                                        + ifaddr.getHostAddress() 
                                                                        + " is not exist on nodeID: " + oldNodeId 
                                                                        +". Reparenting " + ifaddr.getHostAddress() 
                                                                        + " under nodeid " + node.getNodeId());
                						
                					// Get ifindex for this address
                					int index = -1;
                					if (snmpc != null && !snmpc.failed() && snmpc.hasIpAddrTable())
                					{
                						index = IpAddrTable.getIfIndex(snmpc.getIpAddrTable().getEntries(), 
                                                                                                 ifaddr.getHostAddress());
                					}
                					if (log.isDebugEnabled())
                						log.debug("updateInterface: interface " + ifaddr.getHostAddress() 
                                                                        + " has ifIndex " + index);
                					
                					reparentInterface(dbc, ifaddr, index, node.getNodeId(), oldNodeId);
                					
                					// Create interfaceReparented event
                					createInterfaceReparentedEvent(node, oldNodeId, ifaddr);
                					
                					// Set reparent flag
                					reparentFlag = true;
                                                }
                                        }
				}
				
				// Delete the old node id if it has no additional IP interfaces
				// under it...non-IP interfaces do not count as they are only 
				// discoverable via SNMP.
				//
				if (duplicateNodeEntry == null)
					duplicateNodeEntry = DbNodeEntry.get(dbc, oldNodeId);
				
				if (duplicateNodeEntry != null)
				{
					DbIpInterfaceEntry[] duplicateNodeInterfaces = duplicateNodeEntry.getInterfaces(dbc);
					
					if (log.isDebugEnabled())
						log.debug("updateInterface: checking if there are any remaining IP interfaces for this dup node.");
					
					// Determine IP interface count remaining under this node
					int ipCount = 0;
					int nonIpCount = 0;
					for (int ii=0; ii<duplicateNodeInterfaces.length; ii++)
					{
						InetAddress addr = duplicateNodeInterfaces[ii].getIfAddress();
						if (log.isDebugEnabled())
							log.debug("updateInterface: remaining interface address: " + addr.getHostAddress());
						
						// Increment count if address is not "0.0.0.0" and
						// is not a loopback address
						if (!addr.getHostAddress().equals("0.0.0.0") && 
							!addr.getHostAddress().startsWith("127.")) 
						{
							ipCount ++;
						}
						else
						{
							nonIpCount ++;
						}
					}
					if (log.isDebugEnabled())
						log.debug("updateInterface: ipCount=" + ipCount + " nonIpCount=" + nonIpCount);
					
					// If no IP interfaces left we can delete the old
					// node entry
					if (ipCount == 0)
					{
						if (log.isDebugEnabled())
							log.debug("updateInterface: old nodeid " + oldNodeId + " has no IP interfaces associated with it, deleting...");
						
						// If any non IP interface entries remain we must
						// first mark them as deleted.
						if (nonIpCount > 0)
						{
							if (log.isDebugEnabled())
								log.debug("updateInterface: dup nodeid " + oldNodeId + " has at least one non-IP interface associated with it, deleting all non-IP interfaces...");
							
							for (int ii=0; ii<duplicateNodeInterfaces.length; ii++)
							{
								if (log.isDebugEnabled())
									log.debug("updateInterface: deleting non-IP interface with ifIndex " + duplicateNodeInterfaces[ii].getIfIndex() + " from dup node " + oldNodeId);
								duplicateNodeInterfaces[ii].setManagedState(DbIpInterfaceEntry.STATE_DELETED);
								duplicateNodeInterfaces[ii].store(dbc);
							}
						}
						
						// Delete any remaining snmpInterface table entries
						if (log.isDebugEnabled())
							log.debug("updateInterface: deleting any remaining snmpInterface table entries for old node " + oldNodeId);
						PreparedStatement delete = dbc.prepareStatement("DELETE FROM snmpinterface WHERE nodeid=?");
						try
						{
							delete.setInt(1, oldNodeId);
							delete.executeUpdate();
						}
						finally
						{
							try 
							{
								delete.close();
							}
							catch (SQLException e)
							{
								// Do nothing
							}
						}
						
						// Now mark the node as deleted
						duplicateNodeEntry.setNodeType(DbNodeEntry.NODE_TYPE_DELETED);
						duplicateNodeEntry.store(dbc);
						deleteDuplicateNodeFlag = true;
					}
				}
			}
		}

		//
		// IMPORTANT:  Notice that from here on event if the target interface was
		// an alias resulting in the reparenting of multiple interfaces under the
		// target interface's node, we only actually update the current sub-interface.
		// This is ok because this method, updateInterface() should be called 
		// for each sub-interface retrieved via SNMP...and these interfaces no
		// longer need to be reparented so they will be updated as normal.
		if (reparentFlag)
		{
			// Interface was reparented, now we can load its interface entry
			dbIpIfEntry = DbIpInterfaceEntry.get(dbc, node.getNodeId(), ifaddr);
		}
		else if (dbIpIfEntry == null)
		{
			// Interface not found with this nodeId so create new interface entry
			if (log.isDebugEnabled())
				log.debug("updateInterface: interface " + ifaddr + " not in database under nodeid " + node.getNodeId() + ", creating new interface object.");
			dbIpIfEntry = DbIpInterfaceEntry.create(node.getNodeId(), ifaddr, ifIndex);
			newIpIfEntry = true;
		}
		
		// Clone the existing database entry so we have access to the values
		// of the database fields associated with the interface in the event
		// that something has changed.
		DbIpInterfaceEntry originalIpIfEntry = DbIpInterfaceEntry.clone(dbIpIfEntry);
		
		// Create IP interface entry representing latest information
		// retrieved for the interface via the collector
		//
		DbIpInterfaceEntry currIpIfEntry = DbIpInterfaceEntry.create(node.getNodeId(), ifaddr, ifIndex);
			
		// Hostname
		currIpIfEntry.setHostname(ifaddr.getHostName());
			
		// Managed state
		// NOTE: (reference internal bug# 201)
		// If the ip is 'managed', it might still be 'not polled' based
		// on the poller configuration.
		//
		// Try to avoid re-evaluating the ip against filters for
		// each service, try to get the first package here and use
		// that for service evaluation
		//
		// At this point the ip is already/ in the database, so package filter
		// evaluation should go through OK
		//
		org.opennms.netmgt.config.poller.Package ipPkg = null;

		if(cFactory.isAddressUnmanaged(ifaddr))
			currIpIfEntry.setManagedState(DbIpInterfaceEntry.STATE_UNMANAGED);
		else
		{
			boolean ipToBePolled = false;
			ipPkg = pollerCfgFactory.getFirstPackageMatch(ifaddr.getHostAddress());
			if (ipPkg != null)
				ipToBePolled = true;

			if (ipToBePolled)
				currIpIfEntry.setManagedState(DbIpInterfaceEntry.STATE_MANAGED);
			else
				currIpIfEntry.setManagedState(DbIpInterfaceEntry.STATE_NOT_POLLED);
		}
		
		// If SNMP data collection is available set SNMP Primary state 
		// as well as ifIndex and ifStatus.  Also retrieve ifType (loopback
		// interfaces will be skipped).
		//
		int ifType = -1;
		if (snmpc != null && !snmpc.failed())
		{	
			//int ifIndex = snmpc.getIfIndex(ifaddr);
			if(ifIndex != -1)
			{
				currIpIfEntry.setIfIndex(ifIndex);
				int status = snmpc.getAdminStatus(ifIndex);
				currIpIfEntry.setStatus(status);
				ifType = snmpc.getIfType(ifIndex);
				
				// For new interfaces simply set 'isSnmpPrimary' field to secondary for now.  
				// Following the interface updates the primary SNMP interface will be determined
				// and the value of the 'isSnmpPrimary' field set to 'P' (primary) for that
				// interface.
				if (newIpIfEntry)
					currIpIfEntry.setPrimaryState(DbIpInterfaceEntry.SNMP_SECONDARY);
				else
					currIpIfEntry.setPrimaryState(originalIpIfEntry.getPrimaryState());
			}
			else
			{
				// No ifIndex found so set primary state to NOT_ELIGIBLE
				currIpIfEntry.setPrimaryState(DbIpInterfaceEntry.SNMP_NOT_ELIGIBLE);
			}
		}
		
		// Update any fields which have changed
		dbIpIfEntry.setLastPoll(now);
		dbIpIfEntry.updateHostname(currIpIfEntry.getHostname());
		dbIpIfEntry.updateManagedState(currIpIfEntry.getManagedState());
		dbIpIfEntry.updateStatus(currIpIfEntry.getStatus());
		dbIpIfEntry.updatePrimaryState(currIpIfEntry.getPrimaryState());
		dbIpIfEntry.updateIfIndex(currIpIfEntry.getIfIndex());
			
		// Set event flags
		// NOTE:  Must set these flags prior to call to DbIpInterfaceEntry.store()
		// method which will cause the change map to be cleared.
		boolean ifIndexChangedFlag = false;
		boolean ipHostnameChangedFlag = false;
		
		if (dbIpIfEntry.hasIfIndexChanged())
			ifIndexChangedFlag = true;
		
		if (dbIpIfEntry.hasHostnameChanged())
			ipHostnameChangedFlag = true;
		
		// Update the database
		dbIpIfEntry.store(dbc);

		// If the interface was not already in the database under 
		// the node being rescanned or some other node send a
		// nodeGainedInterface event.
		if (newIpIfEntry && !reparentFlag)
		{
			createNodeGainedInterfaceEvent(dbIpIfEntry);
		}
		// If an interface has been reparented send associated events
		else if (reparentFlag)
		{
			// Duplicate node deleted?
			if (deleteDuplicateNodeFlag)
			{
				createDuplicateNodeDeletedEvent(duplicateNodeEntry);
			}
			
			// InterfaceIndexChanged event
			//
			if (log.isDebugEnabled())
				log.debug("updateInterface: ifIndex changed: " + ifIndexChangedFlag);
			if (ifIndexChangedFlag)
			{
				createInterfaceIndexChangedEvent(dbIpIfEntry, originalIpIfEntry);
				m_ifIndexOnNodeChangedFlag = true;
			}
		
			// IPHostNameChanged event
			//
			if (log.isDebugEnabled())
				log.debug("updateInterface: hostname changed: " + ipHostnameChangedFlag);
			if (ipHostnameChangedFlag)
			{
				createIpHostNameChangedEvent(dbIpIfEntry, originalIpIfEntry);
			}
		}
		// If the interface is not new check to see if the interface's
		// ifIndex or ipHostname have changed.
		else
		{
			// InterfaceIndexChanged event
			//
			if (log.isDebugEnabled())
				log.debug("updateInterface: ifIndex changed: " + ifIndexChangedFlag);
			if (ifIndexChangedFlag)
			{
				createInterfaceIndexChangedEvent(dbIpIfEntry, originalIpIfEntry);
				m_ifIndexOnNodeChangedFlag = true;
			}
		
			// IPHostNameChanged event
			//
			if (log.isDebugEnabled())
				log.debug("updateInterface: hostname changed: " + ipHostnameChangedFlag);
			if (ipHostnameChangedFlag)
			{
				createIpHostNameChangedEvent(dbIpIfEntry, originalIpIfEntry);
			}
		}
		
		// Retrieve from the database the interface's service list
		DbIfServiceEntry[] dbSupportedServices = dbIpIfEntry.getServices(dbc);
			
		// add newly supported protocols
		//		
		// NOTE!!!!!: (reference internal bug# 201)
		// If the ip is 'managed', the service can still be 'not polled'
		// based on the poller configuration - at this point the ip is already
		// in the database, so package filter evaluation should go through OK
		//
		Iterator iproto = protocols.iterator();
		while(iproto.hasNext())
		{
			IfCollector.SupportedProtocol p = (IfCollector.SupportedProtocol)iproto.next();
			Number sid = (Number)cFactory.getServiceIdentifier(p.getProtocolName());

			// Only adding newly supported services so check against the service 
			// list retrieved from the database
			boolean found = false;
			for (int i=0; i<dbSupportedServices.length && !found; i++)
			{
				if (dbSupportedServices[i].getServiceId() == sid.intValue())
					found = true;
			}
			if (!found)
			{
				DbIfServiceEntry ifSvcEntry = DbIfServiceEntry.create(node.getNodeId(), ifaddr, sid.intValue());

				// now fill in the entry
				//
				if(cFactory.isAddressUnmanaged(ifaddr))
					ifSvcEntry.setStatus(DbIfServiceEntry.STATUS_UNMANAGED);
				else 
				{
					boolean svcToBePolled = false;
					if (ipPkg != null)
					{
						svcToBePolled = pollerCfgFactory.isPolled(p.getProtocolName(), ipPkg);
						if (!svcToBePolled)
							svcToBePolled = pollerCfgFactory.isPolled(ifaddr.getHostAddress(), p.getProtocolName());
					}

					if (svcToBePolled)
						ifSvcEntry.setStatus(DbIfServiceEntry.STATUS_ACTIVE);
					else
						ifSvcEntry.setStatus(DbIfServiceEntry.STATUS_NOT_POLLED);
				}
				
				// Set qualifier if available.  Currently the qualifier field
				// is used to store the port at which the protocol was found.
				//
				if (p.getQualifiers() != null && p.getQualifiers().get("port") != null)
				{
					try
					{
						Integer port = (Integer)p.getQualifiers().get("port");
						if (log.isDebugEnabled())
							log.debug("addInterfaces: got a port qualifier: " + port);
						ifSvcEntry.setQualifier(port.toString());
					}
					catch (ClassCastException ccE)
					{
						// Do nothing
					}
				}
					
				ifSvcEntry.setSource(DbIfServiceEntry.SOURCE_PLUGIN);
				ifSvcEntry.setNotify(DbIfServiceEntry.NOTIFY_ON);
				
				int index = dbIpIfEntry.getIfIndex();
				if (index > 0)
					ifSvcEntry.setIfIndex(index);
		
				ifSvcEntry.store();
				
				// Generate nodeGainedService event
				createNodeGainedServiceEvent(node, dbIpIfEntry, p.getProtocolName());
				
				// If this interface already existed in the database and SNMP
				// service has been gained then create interfaceSupportsSNMP event
				if (!newIpIfEntry && p.getProtocolName().equalsIgnoreCase("SNMP"))
				{
					createInterfaceSupportsSNMPEvent(dbIpIfEntry);
				}
			}
		} // end while(more protocols)
		
		//
		// If SNMP info is available update the snmpInterface table entry with
		// anything that has changed.
		//		
		if (snmpc != null && !snmpc.failed() && dbIpIfEntry.getIfIndex() != -1)
		{
			if (log.isDebugEnabled())
				log.debug("updateInterface: updating snmp interface for nodeId/ifIndex=" +
					+ node.getNodeId() + "/" + dbIpIfEntry.getIfIndex());
			
			// Create and load SNMP Interface entry from the database
			//
			boolean newSnmpIfTableEntry = false;
			DbSnmpInterfaceEntry dbSnmpIfEntry = DbSnmpInterfaceEntry.get(dbc, node.getNodeId(), dbIpIfEntry.getIfIndex());
			if (dbSnmpIfEntry == null)
			{
				// SNMP Interface not found with this nodeId, create new interface
				if (log.isDebugEnabled())
					log.debug("updateInterface: SNMP interface index " + dbIpIfEntry.getIfIndex() + " not in database, creating new interface object.");
				dbSnmpIfEntry = DbSnmpInterfaceEntry.create(node.getNodeId(), dbIpIfEntry.getIfIndex());
				newSnmpIfTableEntry = true;
			}
		
			// Create SNMP interface entry representing latest information
			// retrieved for the interface via the collector
			//
			DbSnmpInterfaceEntry currSnmpIfEntry = DbSnmpInterfaceEntry.create(node.getNodeId(), dbIpIfEntry.getIfIndex());
			
			// Find the ifTable entry for this interface
			IfTable ift = snmpc.getIfTable();
			Iterator ifiter = ift.getEntries().iterator();
			IfTableEntry ifte = null;
			while(ifiter.hasNext())
			{
				ifte = (IfTableEntry)ifiter.next();
				
				// index
				//
				SnmpInt32 sint = (SnmpInt32)ifte.get(IfTableEntry.IF_INDEX);
				if(sint != null)
				{
					if (dbIpIfEntry.getIfIndex() == sint.getValue())
						break;
				}
			}
			
			// Make sure we have a valid IfTableEntry object
			if (ifte != null)
			{
				// IP address and netmask
				//
				// WARNING:  IfSnmpCollector.getIfAddressAndMask() ONLY returns
				// the FIRST IP address and mask for a given interface as specified
				// in the ipAddrTable.
				//
				InetAddress[] aaddrs = snmpc.getIfAddressAndMask(dbIpIfEntry.getIfIndex());

				// Address array should NEVER be null but just in case..
				//
				if(aaddrs == null)
				{
					log.warn("updateInterface: unable to retrieve address and netmask for nodeId/ifIndex: " +
						node.getNodeId() + "/" + dbIpIfEntry.getIfIndex());

					aaddrs = new InetAddress[2];

					// Set interface address to current interface
					aaddrs[0] = ifaddr;

					// Set netmask to NULL
					aaddrs[1] = null;
				}

				// IP address
				//
				currSnmpIfEntry.setIfAddress(aaddrs[0]);
				
				// netmask
				//
				if (aaddrs[1] != null)
				{
					if (log.isDebugEnabled()) 
						log.debug("updateInterface: interface " + aaddrs[0].getHostAddress() 
                                                        + " has netmask: " + aaddrs[1].getHostAddress());
					currSnmpIfEntry.setNetmask(aaddrs[1]);
				}
				
				// type
				//
				SnmpInt32 sint = (SnmpInt32)ifte.get(IfTableEntry.IF_TYPE);
				currSnmpIfEntry.setType(sint.getValue());
					
				// description
				String str = SystemGroup.getPrintableString((SnmpOctetString)ifte.get(IfTableEntry.IF_DESCR));
				if (log.isDebugEnabled())
					log.debug("updateInterface: " + ifaddr + " has ifDescription: " + str);
				if(str != null && str.length() > 0)
					currSnmpIfEntry.setDescription(str);
					
				// physical address
				StringBuffer sbuf = new StringBuffer();
				SnmpOctetString ostr = (SnmpOctetString)ifte.get(IfTableEntry.IF_PHYS_ADDR);
                                if ( ostr != null && ostr.getLength() > 0)
                                {
					byte[] bytes = ostr.getString();
					for(int i = 0; i < bytes.length; i++)
					{
						sbuf.append(Integer.toHexString(((int)bytes[i] >> 4) & 0xf));
						sbuf.append(Integer.toHexString((int)bytes[i] & 0xf));
					}
				}
				
				String physAddr = sbuf.toString().trim();
			
				if (log.isDebugEnabled())
					log.debug("updateInterface: " + ifaddr + " has phys address: -" + physAddr + "-");
				
				if (physAddr.length() == 12)
				{
					currSnmpIfEntry.setPhysicalAddress(physAddr);
				}
			
				// speed
				SnmpUInt32 uint = (SnmpUInt32)ifte.get(IfTableEntry.IF_SPEED);
				currSnmpIfEntry.setSpeed((int)uint.getValue());

				// admin status
				sint = (SnmpInt32)ifte.get(IfTableEntry.IF_ADMIN_STATUS);
				currSnmpIfEntry.setAdminStatus(sint.getValue());
						
				// oper status
				sint = (SnmpInt32)ifte.get(IfTableEntry.IF_OPER_STATUS);
				currSnmpIfEntry.setOperationalStatus(sint.getValue());
				
				// name (from interface extensions table)
				SnmpOctetString snmpIfName = snmpc.getIfName(dbIpIfEntry.getIfIndex());
				if (snmpIfName != null)
				{
					String ifName = SystemGroup.getPrintableString(snmpIfName);
					if (ifName!= null  && ifName.length() > 0)
						currSnmpIfEntry.setName(ifName);
				}
					
			} // end if valid ifTable entry
			
			// Update any fields which have changed
			//dbSnmpIfEntry.updateIfIndex(currSnmpIfEntry.getIfIndex());
			dbSnmpIfEntry.updateIfAddress(currSnmpIfEntry.getIfAddress());
			dbSnmpIfEntry.updateNetmask(currSnmpIfEntry.getNetmask());
			dbSnmpIfEntry.updatePhysicalAddress(currSnmpIfEntry.getPhysicalAddress());
			dbSnmpIfEntry.updateDescription(currSnmpIfEntry.getDescription());
			dbSnmpIfEntry.updateName(currSnmpIfEntry.getName());
			dbSnmpIfEntry.updateType(currSnmpIfEntry.getType());
			dbSnmpIfEntry.updateSpeed(currSnmpIfEntry.getSpeed());
			dbSnmpIfEntry.updateAdminStatus(currSnmpIfEntry.getAdminStatus());
			dbSnmpIfEntry.updateOperationalStatus(currSnmpIfEntry.getOperationalStatus());
			
			// If this is a new interface or if any of the following 
			// key fields have changed set the m_snmpIfTableChangedFlag 
			// variable to TRUE.  This will potentially trigger an event 
			// which will cause the poller to reinitialize the primary 
			// SNMP interface for the node.
			if (!m_snmpIfTableChangedFlag &&
				newSnmpIfTableEntry || 
				//dbSnmpIfEntry.hasIfIndexChanged() ||
				dbSnmpIfEntry.hasIfAddressChanged() ||
				dbSnmpIfEntry.hasTypeChanged() ||
				dbSnmpIfEntry.hasNameChanged() ||
				dbSnmpIfEntry.hasDescriptionChanged() ||
				dbSnmpIfEntry.hasPhysicalAddressChanged())
			{
				m_snmpIfTableChangedFlag = true;
			}
			
			// Update the database
			dbSnmpIfEntry.store(dbc);
		} // end if snmp info available
	}


	/**
	 * This method checks if a given ipaddress is in the ipAddrTable of a given
         * node. If the ipaddress is in the ipAddrtable of a specific node, return 
         * true, otherwise return false.
	 * 
	 * @param node		DbNodeEntry object 
	 * @param ifaddr	the interface to check
	 */
        private boolean isInIpAddrTable(InetAddress ipAddress, DbNodeEntry oldNode)
        {

		Category log = ThreadCategory.getInstance(getClass());

		// Retrieve all the interfaces
		// associated with the old node and perform collections against them.  
		// 
		DbIpInterfaceEntry[] dbInterfaces = null;
		
		// Retrieve list of interfaces associated with this nodeID
		// from the database
		log.debug("isInIpAddrTable: retrieving all interfaces for node: " + oldNode.getNodeId());
		try
		{
			dbInterfaces = oldNode.getInterfaces();
		}
		catch (NullPointerException npE)
		{
			log.error("isInIpAddrTable: Null pointer when retrieving interfaces for node " + oldNode.getNodeId(), npE);
			return false;
		}
		catch (SQLException sqlE)
		{
			log.error("isInIpAddrTable: unable to load interface info for nodeId " + oldNode.getNodeId() 
                                + " from the database.", sqlE);
			return false;
		}

		// Run collector for each retrieved interface 
		// 
                IfCollector collector = null;
		IfSnmpCollector snmpc = null;
		boolean doSnmpCollection = true;
		for (int i=0; i<dbInterfaces.length && doSnmpCollection; i++)
		{
			InetAddress ifaddr = dbInterfaces[i].getIfAddress();
				
			// collect the information from the interface.  
			// NOTE: skip '127.*.*.*' and '0.0.0.0' addresses.
			if(ifaddr.getHostAddress().startsWith("127") || 
				ifaddr.getHostAddress().equals("0.0.0.0"))
			{
				continue;
			}

			if (log.isDebugEnabled())
				log.debug("isInIpAddrTable: running collection for " + ifaddr.getHostAddress());
			
			collector = new IfCollector(ifaddr, doSnmpCollection);
			collector.run();
			
			// Only need to collect SNMP data from one of the
			// node's interfaces. 
			//
			if (doSnmpCollection)
			{
				snmpc = collector.getSnmpCollector();
				if (snmpc != null && !snmpc.failed())
				{
                                        if (areDbInterfacesInSnmpCollection(dbInterfaces, snmpc))
					{
                                                // Got a successful SNMP collection from the node
					        doSnmpCollection = false;
					
					        if (log.isDebugEnabled())
						        log.debug("isInIpAddrTable: SNMP data collected via " 
                                                                + ifaddr.getHostAddress());
                                        }
                                        else
                                        {
					        if (log.isDebugEnabled())
						        log.debug("isInIpAddrTable: SNMP data collected via " 
                                                                + ifaddr.getHostAddress() + " is not right." 
                                                                + " Try to collect SNMP data through another ip address.");
                                        }
				}
			}

			if (log.isDebugEnabled())
				log.debug("isInIpAddrTable: collection completed for " + ifaddr.getHostAddress());
		}

                // Check if a given ipAddress is on the ipAddrTable of the oldNode
                return !isInterfaceAlias(ipAddress, snmpc);
        }


	/**
	 * This method is responsble for inserting a new entry into the ipInterface
	 * table and all its supported protocols into ifservices table for a given node.
	 * 
	 * @param node		DbNodeEntry object representing the rescaning interface's
	 *                      parent node table entry
	 * @param ifaddr	Rescaning interface
	 * @param protocols	Protocols supported by the interface.
	 * @param snmpc		SNMP collector or null if SNMP not supported.
	 * 
	 * @throws SQLException if there is a problem updating the ipInterface table.
	 */
	private DbIpInterfaceEntry addDuplicateInterface( DbNodeEntry node,
				   InetAddress ifaddr,
                                   List protocols,
				   IfSnmpCollector snmpc)
		throws SQLException
	{
		Category log = ThreadCategory.getInstance(getClass());

		CapsdConfigFactory cFactory = CapsdConfigFactory.getInstance();
		PollerConfigFactory pollerCfgFactory = PollerConfigFactory.getInstance();

		Date now = new Date();

		// if there is no snmp information then it's a
		// simple addtion to the database
		//
		if(snmpc != null || !snmpc.failed())
		{
			if (log.isDebugEnabled())
				log.debug("AddDuplicateInterface: add interface " + ifaddr.getHostAddress()
                                        + " for nodeId: " + node.getNodeId());
                                        
			DbIpInterfaceEntry ipIfEntry = DbIpInterfaceEntry.create(node.getNodeId(), ifaddr);
			ipIfEntry.setLastPoll(now);
			ipIfEntry.setHostname(ifaddr.getHostName());

			// The package filter evaluation requires that the ip be in the
			// database - at this point the ip is NOT in db, so insert as active
			// and update afterward
			//
			// Try to avoid re-evaluating the ip against filters for
			// each service, try to get the first package here and use
			// that for service evaluation
			//
			boolean addrUnmanaged = cFactory.isAddressUnmanaged(ifaddr);
			if(addrUnmanaged)
				ipIfEntry.setManagedState(DbIpInterfaceEntry.STATE_UNMANAGED);
			else
				ipIfEntry.setManagedState(DbIpInterfaceEntry.STATE_MANAGED);

			ipIfEntry.setPrimaryState(DbIpInterfaceEntry.SNMP_NOT_ELIGIBLE);

			ipIfEntry.store();

			// now update if necessary
			org.opennms.netmgt.config.poller.Package ipPkg = null;
			if (!addrUnmanaged)
			{
				boolean ipToBePolled = false;
				ipPkg = pollerCfgFactory.getFirstPackageMatch(ifaddr.getHostAddress());
				if (ipPkg != null)
					ipToBePolled = true;

				if (!ipToBePolled)
				{
					// update ismanaged to 'N' in ipinterface
					ipIfEntry.setManagedState(DbIpInterfaceEntry.STATE_NOT_POLLED);
					ipIfEntry.store();
				}
			}

			int ifIndex = -1;
			if((ifIndex = snmpc.getIfIndex(ifaddr)) != -1)
			{
			        // Just set primary state to secondary for now.  The primary SNMP interface
			        // won't be selected until after all interfaces have been inserted
			        // into the database. This is because the interface must already be in
			        // the database for filter rule evaluation to succeed.
				ipIfEntry.setPrimaryState(DbIpInterfaceEntry.SNMP_SECONDARY);
			
				ipIfEntry.setIfIndex(ifIndex);
				int status = snmpc.getAdminStatus(ifIndex);
				if(status != -1)
					ipIfEntry.setStatus(status);
			}
			else
			{
				// Address does not have a valid ifIndex associated with it
				// so set primary state to NOT_ELIGIBLE.
				ipIfEntry.setPrimaryState(DbIpInterfaceEntry.SNMP_NOT_ELIGIBLE);
			}

			ipIfEntry.store();
                        createDuplicateIpAddressEvent(ipIfEntry);

			// Add supported protocols
			if (log.isDebugEnabled())
				log.debug("AddDuplicateInterface: add supported protocols for interface " + ifaddr.getHostAddress()
                                        + " /nodeId: " + node.getNodeId());
			addSupportedProtocols(node, 
						ipIfEntry, 
					        protocols, 
						addrUnmanaged, 
						ifIndex, 
						ipPkg);
                        return ipIfEntry;
                }
                return null;
	}


	/**
	 * Responsible for iterating inserting an entry into the ifServices
	 * table for each protocol supported by the interface.
	 *
	 * @param node		Node entry
	 * @param ipIfEntry 	DbIpInterfaceEntry object
	 * @param protocols	List of supported protocols
	 * @param addrUnmanaged Boolean flag indicating if interface is managed or
	 *                      unmanaged according to the Capsd configuration.
	 * @param ifIndex 	Interface index or -1 if index is not known
	 * @param ipPkg		Poller package to which the interface belongs
	 *
	 * @throws SQLException if an error occurs adding interfaces to the ipInterface 
	 *                      table.
	 */
	private void addSupportedProtocols(DbNodeEntry node, 
					DbIpInterfaceEntry ipIfEntry, 
					List protocols, 
					boolean addrUnmanaged,
					int ifIndex, 
					org.opennms.netmgt.config.poller.Package ipPkg)
		throws SQLException
	{
		InetAddress ifaddr = ipIfEntry.getIfAddress();
                
                // add the supported protocols
		//
		Iterator iproto = protocols.iterator();
		while(iproto.hasNext())
		{
			IfCollector.SupportedProtocol p = (IfCollector.SupportedProtocol)iproto.next();
			Number sid = (Number)CapsdConfigFactory.getInstance().getServiceIdentifier(p.getProtocolName());

			DbIfServiceEntry ifSvcEntry = DbIfServiceEntry.create(node.getNodeId(), 
                                                                              ifaddr, sid.intValue());

			// now fill in the entry
			//
			if(addrUnmanaged)
				ifSvcEntry.setStatus(DbIfServiceEntry.STATUS_UNMANAGED);
			else 
			{
				boolean svcToBePolled = false;
				if (ipPkg != null)
				{
					svcToBePolled = PollerConfigFactory.getInstance().isPolled(p.getProtocolName(), ipPkg);
					if (!svcToBePolled)
						svcToBePolled = PollerConfigFactory.getInstance().isPolled(ifaddr.getHostAddress(), 
                                                                                                           p.getProtocolName());
				}

				if (svcToBePolled)
					ifSvcEntry.setStatus(DbIfServiceEntry.STATUS_ACTIVE);
				else
					ifSvcEntry.setStatus(DbIfServiceEntry.STATUS_NOT_POLLED);
			}

			// Set qualifier if available.  Currently the qualifier field
			// is used to store the port at which the protocol was found.
			//
			if (p.getQualifiers() != null && p.getQualifiers().get("port") != null)
			{
				try
				{
					Integer port = (Integer)p.getQualifiers().get("port");
					ifSvcEntry.setQualifier(port.toString());
				}
				catch (ClassCastException ccE)
				{
					// Do nothing
				}
			}
				
			ifSvcEntry.setSource(DbIfServiceEntry.SOURCE_PLUGIN);
			ifSvcEntry.setNotify(DbIfServiceEntry.NOTIFY_ON);
			if(ifIndex != -1)
				ifSvcEntry.setIfIndex(ifIndex);
			ifSvcEntry.store();
		}
	}
	

	/**
	 * This method is responsible for reparenting an interface's database
	 * table entries under its new node identifier.  The following tables
	 * are updated:
	 *
	 * 	ipInterface
	 *  	snmpInterface
	 * 	ifServices
	 *
	 * @param dbc		Database connection
	 * @param ifAddr	Interface to be reparented.
	 * @param newNodeId	Interface's new node identifier
	 * @param oldNodeId	Interfaces' old node identifier
	 * 
	 * @throws SQLException if a database error occurs during reparenting. 
	 */
	private void reparentInterface(Connection  dbc,
				InetAddress 	ifAddr,
				int             ifIndex,
				int 		newNodeId,
				int		oldNodeId)
		throws SQLException
	{
		Category log = ThreadCategory.getInstance(getClass());
		
		// Reparent the interface
		//
		PreparedStatement ipInterfaceStmt = dbc.prepareStatement(SQL_DB_REPARENT_IP_INTERFACE);
		PreparedStatement snmpIfLookupStmt = dbc.prepareStatement(SQL_DB_REPARENT_SNMP_IF_LOOKUP);
		PreparedStatement snmpIfDeleteStmt = dbc.prepareStatement(SQL_DB_REPARENT_SNMP_IF_DELETE);
		PreparedStatement snmpInterfaceStmt = dbc.prepareStatement(SQL_DB_REPARENT_SNMP_INTERFACE);
		PreparedStatement ifServicesStmt = dbc.prepareStatement(SQL_DB_REPARENT_IF_SERVICES);
		
		try
		{
			log.debug("reparentInterfaces: reparenting address/ifIndex/nodeID: " + ifAddr.getHostAddress() + "/" + ifIndex + "/" + newNodeId);
			
			// Update the 'ipInterface' table entry so that this
			// interface's nodeID is set to the value of reparentNodeID
			ipInterfaceStmt.setInt(1, newNodeId);
			ipInterfaceStmt.setInt(2, oldNodeId);
			ipInterfaceStmt.setString(3, ifAddr.getHostAddress());
					
			// execute and log
			ipInterfaceStmt.executeUpdate();
			
			// SNMP interface
			//
			// NOTE:  Only reparent SNMP interfaces if we have valid ifIndex
			if (ifIndex < 1)
			{
				log.debug("reparentInterfaces: don't have a valid ifIndex, skipping snmpInterface table reparenting.");
			}
			else
			{
				// NOTE:  Now that the snmpInterface table is uniquely keyed
				//        by nodeId and ifIndex we must only reparent the
				//        old entry if there isn't already an entry with 
				//        the same nodeid/ifindex pairing.  If it can't
				//        be reparented it will be deleted.
				
				// Look for matching nodeid/ifindex for the entry to be reparented
				boolean alreadyExists = false;
				snmpIfLookupStmt.setInt(1, newNodeId);
				snmpIfLookupStmt.setInt(2, ifIndex);
				ResultSet rs = snmpIfLookupStmt.executeQuery();
				if (rs.next())
				{
					// Looks like we got a match so just delete
					// the entry from the old node
					log.debug("interface with ifindex " + ifIndex + " already exists under new node " + newNodeId + ", deleting from under old node " + oldNodeId);
					alreadyExists = true;
					
					snmpIfDeleteStmt.setInt(1, oldNodeId);
					snmpIfDeleteStmt.setInt(2, ifIndex);
					
					snmpIfDeleteStmt.executeUpdate();
				}
				
				if (alreadyExists == false)
				{
					// Update the 'snmpinterface' table entry so that this
					// interface's nodeID is set to the value of reparentNodeID
					//
					log.debug("interface with ifindex " + ifIndex + " does not yet exist under new node " + newNodeId + ", reparenting.");
					
					snmpInterfaceStmt.setInt(1, newNodeId);
					snmpInterfaceStmt.setInt(2, oldNodeId);
					snmpInterfaceStmt.setInt(3, ifIndex);
							
					// execute and log
					snmpInterfaceStmt.executeUpdate();
				}
			}
			
			// Update the 'nodeID' field of all 'ifservices' table entries for 
			// the reparented interfaces.
			ifServicesStmt.setInt(1, newNodeId);
			ifServicesStmt.setInt(2, oldNodeId);
			ifServicesStmt.setString(3, ifAddr.getHostAddress());
					
			// execute and log
			ifServicesStmt.executeUpdate();
					
			log.debug("reparentInterface: reparented " + ifAddr.getHostAddress() + 
						" : ifIndex: " + ifIndex +
						" : oldNodeID: " + oldNodeId + 
						" newNodeID: " + newNodeId);
		}	
		catch(SQLException sqlE)
		{
			log.error("SQLException while reparenting addr/ifindex/nodeid " + ifAddr.getHostAddress() + "/" + ifIndex + "/" + oldNodeId);
			throw sqlE;
		}
		finally
		{
			ipInterfaceStmt.close();
			snmpIfLookupStmt.close();
			snmpIfDeleteStmt.close(); 
			snmpInterfaceStmt.close();
			ifServicesStmt.close();
		}
	}
	
	/** 
	 * Builds a list of InetAddress objects representing each of
	 * the interfaces from the collector map object which support SNMP
	 * and have a valid ifIndex and have an IfType of loopback.
	 * 
	 * This is part of a feature to choose a non 127.*.*.* loopback
	 * address as the primary SNMP interface.
	 *
	 * @param collectorMap Map of IfCollector objects containing data collected
	 * 			from all of the node's interfaces.
	 * @param snmpc	 Reference to SNMP collection object
	 *
	 * @return List of InetAddress objects.
	 */
	private static List buildLBSnmpAddressList(Map collectorMap, IfSnmpCollector snmpc)
	{
		Category log = ThreadCategory.getInstance(RescanProcessor.class);
		
		List addresses = new ArrayList();
		
		// Verify that we have SNMP info
		if (snmpc == null)
		{
			if (log.isDebugEnabled())
				log.debug("buildLBSnmpAddressList: no SNMP info available...");
			return addresses;
		}
			
		// To be eligible to be the primary SNMP interface for a node:
		// 
		// 1. The interface must support SNMP
		// 2. The interface must have a valid ifIndex.
		//
		Collection values = collectorMap.values();
		Iterator iter = values.iterator();
		while(iter.hasNext())
		{
			IfCollector ifc = (IfCollector)iter.next();
			
			// Add eligible target.
			//
			InetAddress ifaddr = ifc.getTarget();
			
			if (addresses.contains(ifaddr) == false)
			{
				if ( SuspectEventProcessor.supportsSnmp(ifc.getSupportedProtocols()) && 
					SuspectEventProcessor.hasIfIndex(ifaddr, snmpc) && SuspectEventProcessor.getIfType(ifaddr, snmpc) == 24)
				{
					if (log.isDebugEnabled())
						log.debug("buildLBSnmpAddressList: adding target interface " + ifaddr.getHostAddress() + " temporarily marked as primary!");
					addresses.add(ifaddr);
				}
			}

			// Now go through list of sub-targets
			if (ifc.hasAdditionalTargets())
			{
				Map subTargets = ifc.getAdditionalTargets();
				Set keys = subTargets.keySet();
				Iterator siter = keys.iterator();
				
				while(siter.hasNext())
				{
					// Add eligible subtargets.  
					//
					InetAddress xifaddr = (InetAddress)siter.next();
					if (addresses.contains(xifaddr) == false)
					{
						if (SuspectEventProcessor.supportsSnmp((List)subTargets.get(xifaddr)) && 
							SuspectEventProcessor.hasIfIndex(xifaddr, snmpc) && SuspectEventProcessor.getIfType(xifaddr, snmpc) == 24)
						{ 
							if (log.isDebugEnabled())
								log.debug("buildLBSnmpAddressList: adding subtarget interface " + xifaddr.getHostAddress() + " temporarily marked as primary!");
							addresses.add(xifaddr);
						}
					}
				}
			}
		}
		
		return addresses;
	}
	
	
	/** 
	 * Builds a list of InetAddress objects representing each of
	 * the interfaces from the collector map object which support SNMP
	 * and have a valid ifIndex.
	 *
	 * @param collectorMap Map of IfCollector objects containing data collected
	 * 			from all of the node's interfaces.
	 * @param snmpc	 Reference to SNMP collection object
	 *
	 * @return List of InetAddress objects.
	 */
	private static List buildSnmpAddressList(Map collectorMap, IfSnmpCollector snmpc)
	{
		Category log = ThreadCategory.getInstance(RescanProcessor.class);
		
		List addresses = new ArrayList();
		
		// Verify that we have SNMP info
		if (snmpc == null)
		{
			if (log.isDebugEnabled())
				log.debug("buildSnmpAddressList: no SNMP info available...");
			return addresses;
		}
			
		// To be eligible to be the primary SNMP interface for a node:
		// 
		// 1. The interface must support SNMP
		// 2. The interface must have a valid ifIndex.
		//
		Collection values = collectorMap.values();
		Iterator iter = values.iterator();
		while(iter.hasNext())
		{
			IfCollector ifc = (IfCollector)iter.next();
			
			// Add eligible target.
			//
			InetAddress ifaddr = ifc.getTarget();
			
			if (addresses.contains(ifaddr) == false)
			{
				if ( SuspectEventProcessor.supportsSnmp(ifc.getSupportedProtocols()) && 
					SuspectEventProcessor.hasIfIndex(ifaddr, snmpc) )
				{
					if (log.isDebugEnabled())
						log.debug("buildSnmpAddressList: adding target interface " + ifaddr.getHostAddress() + " temporarily marked as primary!");
					addresses.add(ifaddr);
				}
			}

			// Now go through list of sub-targets
			if (ifc.hasAdditionalTargets())
			{
				Map subTargets = ifc.getAdditionalTargets();
				Set keys = subTargets.keySet();
				Iterator siter = keys.iterator();
				
				while(siter.hasNext())
				{
					// Add eligible subtargets.  
					//
					InetAddress xifaddr = (InetAddress)siter.next();
					if (addresses.contains(xifaddr) == false)
					{
						if (SuspectEventProcessor.supportsSnmp((List)subTargets.get(xifaddr)) && 
							SuspectEventProcessor.hasIfIndex(xifaddr, snmpc) )
						{ 
							if (log.isDebugEnabled())
								log.debug("buildSnmpAddressList: adding subtarget interface " + xifaddr.getHostAddress() + " temporarily marked as primary!");
							addresses.add(xifaddr);
						}
					}
				}
			}
		}
		
		return addresses;
	}
	
	/**
	 * This method is responsible for determining the primary IP interface 
	 * for the node being rescanned.
	 *
	 * @param collectorMap 	Map of IfCollector objects containing data collected
	 * 			from all of the node's interfaces.
	 * 
	 * @return InetAddress 	The primary IP interface for the node or null if
	 *   			a primary interface for the node could not be determined.
	 */
	private InetAddress determinePrimaryIpInterface(Map collectorMap)
	{
		Category log = ThreadCategory.getInstance(getClass());
		
		// For now hard-coding primary interface address selection method to MIN
		String method = SELECT_METHOD_MIN;
		
		Collection values = collectorMap.values();
		Iterator iter = values.iterator();
		InetAddress primaryIf = null;
		while(iter.hasNext())
		{
			IfCollector ifc = (IfCollector)iter.next();
			InetAddress currIf = ifc.getTarget();

			if (primaryIf == null)
			{
				primaryIf = currIf;
				continue;
			}
			else
			{
				// Test the target interface of the collector first.
				primaryIf = SuspectEventProcessor.compareAndSelectPrimary(currIf, primaryIf, method);
				
				// Now test each of the collected subtargets
				if (ifc.hasAdditionalTargets())
				{
					Map subTargets = ifc.getAdditionalTargets();
					Set keys = subTargets.keySet();
					Iterator siter = keys.iterator();
					
					while(siter.hasNext())
					{
						currIf = (InetAddress)siter.next();
						primaryIf = SuspectEventProcessor.compareAndSelectPrimary(currIf, primaryIf, method);
					}
				}
			}
		}
		
		if (log.isDebugEnabled())
			if (primaryIf != null)
				log.debug("determinePrimaryIpInterface: selected primary interface: " + primaryIf.getHostAddress());
			else
				log.debug("determinePrimaryIpInterface: no primary interface found");
		return primaryIf;
	}
	
	/**
	 * Primarily, this method is responsible for assigning the node's nodeLabel
	 * value using information collected from the node's various interfaces.
	 * Additionally, if the node talks NetBIOS/SMB, then the node's NetBIOS name
	 * and operating system fields are assigned.
	 *
	 * @param collectorMap		Map of IfCollector objects, one per interface.
	 * @param dbNodeEntry		Node entry, as it exists in the database.
	 * @param currNodeEntry		Current node entry, as collected during the 
	 * 				current rescan.
	 * @param currPrimarySnmpIf	Primary SNMP interface, as determined from the
	 * 				collection retrieved during the current rescan.
	 */
	private void setNodeLabelAndSmbInfo(Map         collectorMap,
					    DbNodeEntry dbNodeEntry,
					    DbNodeEntry currNodeEntry,
					    InetAddress	currPrimarySnmpIf)
	{
		Category log = ThreadCategory.getInstance(getClass());
		
		boolean labelSet = false;

		// We are going to change the order in which labels are assigned.
		// First, we check DNS - the hostname of the primary interface.
		// Then we check SMB - next SNMP sysName - and finally IP address
		// This is different then in 1.0 - when SMB came first.

		InetAddress primaryIf = null;
	
		if (!labelSet)
		{
			// If no label is set, attempt to get the hostname for the primary SNMP interface.
			// Note: this was wrong prior to 1.0.1 - the method determinePrimaryIpInterface
			// would return the lowest numbered interface, not necessarily the primary
			// SNMP interface.
			if (currPrimarySnmpIf != null)
			{
				primaryIf = currPrimarySnmpIf;
			}
			else
			{
			primaryIf = determinePrimaryIpInterface(collectorMap);
			}
			if (primaryIf == null)
			{
				log.error("setNodeLabelAndSmbInfo: failed to find primary interface...");
			}
			else
			{
				String hostName = primaryIf.getHostName();
				if (!hostName.equals(primaryIf.getHostAddress()))
				{
					labelSet = true;
							
					currNodeEntry.setLabel(hostName);
					currNodeEntry.setLabelSource(DbNodeEntry.LABEL_SOURCE_HOSTNAME);
				}
			}
		}

		IfSmbCollector savedSmbcRef = null;
		
		// Does the node entry in database have a NetBIOS name?
		//
		if (dbNodeEntry.getNetBIOSName() != null)
		{
			// Yes it does, so search through collected info for all 
			// interfaces and see if any have a NetBIOS name
			// which matches the existing one in the database
			Collection values = collectorMap.values();
			Iterator iter = values.iterator();
			while(iter.hasNext() && !labelSet)
			{
				IfCollector ifc = (IfCollector)iter.next();
				IfSmbCollector smbc = ifc.getSmbCollector();
				if (smbc != null)
				{
					if(smbc.getNbtName() != null)
					{
						// Save reference to first IfSmbCollector object
						// for future use.
						savedSmbcRef = smbc;
						
						String netbiosName = smbc.getNbtName().toUpperCase();
						if (netbiosName.equals(dbNodeEntry.getNetBIOSName()))
						{
							// Found a match.
							labelSet = true;
							
							currNodeEntry.setLabel(netbiosName);
							currNodeEntry.setLabelSource(DbNodeEntry.LABEL_SOURCE_NETBIOS);
							currNodeEntry.setNetBIOSName(netbiosName);
							
							if(smbc.getDomainName() != null)
								currNodeEntry.setDomainName(smbc.getDomainName());

							if(smbc.getOS() != null)
								currNodeEntry.setOS(smbc.getOS());
						}
					}
				}
			}
		}
		else
		{
			// No it does not, attempt to find an interface 
			// collector that does have a NetBIOS name and
			// save a reference to that collector
			//
			Collection values = collectorMap.values();
			Iterator iter = values.iterator();
			while(iter.hasNext())
			{
				IfCollector ifc = (IfCollector)iter.next();
				IfSmbCollector smbc = ifc.getSmbCollector();
				if (smbc != null && smbc.getNbtName() != null)
				{
					savedSmbcRef = smbc;
				}
			}
		}

		// If node label has not yet been set and SMB info is available 
		// use that info to set the node label and NetBIOS name
		//
		if (!labelSet && savedSmbcRef != null)
		{
			labelSet = true;
					
			currNodeEntry.setLabel(savedSmbcRef.getNbtName());
			currNodeEntry.setLabelSource(DbNodeEntry.LABEL_SOURCE_NETBIOS);
			currNodeEntry.setNetBIOSName(currNodeEntry.getLabel());
					
			if(savedSmbcRef.getDomainName() != null)
				currNodeEntry.setDomainName(savedSmbcRef.getDomainName());
					
			if(savedSmbcRef.getOS() != null)
				currNodeEntry.setOS(savedSmbcRef.getOS());
		}
		
		
		// If we get this far no IP hostname or SMB info was available.  Next we want
		// to use MIB-II sysName for the node label.  The primary SNMP interface
		// has already been determined so use it if available.
		if (!labelSet && currPrimarySnmpIf != null)
		{
			// We prefer to use the collector for the primary SNMP interface
			// however a collector for the primary SNMP interface may not exist
			// in the map if a node has only recently had SNMP support enabled
			// or if the new primary SNMP interface was only recently added to the
			// node.  At any rate if it exists use it, if not use the
			// first collector which supports SNMP.
			IfCollector ifc = (IfCollector)collectorMap.get(currPrimarySnmpIf.getHostAddress());
			if (ifc == null)
			{
				Collection collectors = collectorMap.values();
				Iterator iter = collectors.iterator();
				while (iter.hasNext())
				{
					ifc = (IfCollector)iter.next();
					if (ifc.getSnmpCollector() != null)
						break;
				}
			}

			// Sanity check
			if (ifc == null || ifc.getSnmpCollector() == null)
			{
				log.warn("setNodeLabelAndSmbInfo: primary SNMP interface set to " + currPrimarySnmpIf.getHostAddress() + " but no SNMP collector found.");
			}
			else
			{
			IfSnmpCollector snmpc = ifc.getSnmpCollector();
			SystemGroup sysgrp = snmpc.getSystemGroup();
			
			String str = SystemGroup.getPrintableString((SnmpOctetString)sysgrp.get(SystemGroup.SYS_NAME));
			if(str != null && str.length() > 0)
				{
					labelSet = true;
					currNodeEntry.setLabel(str);
					currNodeEntry.setLabelSource(DbNodeEntry.LABEL_SOURCE_SYSNAME);
			}
		}
		}
		
		if (!labelSet)
		{
			// If we get this far no SNMP info was available so we will default
			// to the IP address of the primary interface.
			if (primaryIf != null)
			{
				currNodeEntry.setLabel(primaryIf.getHostAddress());
				currNodeEntry.setLabelSource(DbNodeEntry.LABEL_SOURCE_ADDRESS);
			} 
			else
			{
				// If all else fails, just use the current values from
				// the database.
				currNodeEntry.setLabel(dbNodeEntry.getLabel());
				currNodeEntry.setLabelSource(dbNodeEntry.getLabelSource());
			}
		}
	}
	
	/**
	 * Utility method used to determine if the specified node has been
	 * marked as deleted in the node table.
	 * 
	 * @param dbc		Database connection.
	 * @param nodeId	Node identifier to check
	 *
	 * @return TRUE if node has been marked as deleted, FALSE otherwise.
	 */
	private boolean isNodeDeleted(Connection dbc, int nodeId)
		throws SQLException
	{
		boolean nodeDeleted = false;
		
		// Prepare & execute the SQL statement to retrieve the 'nodetype' field 
		// from the node table for the specified nodeid.
		PreparedStatement stmt = null;
		try
		{
			stmt = dbc.prepareStatement(SQL_DB_RETRIEVE_NODE_TYPE);
			stmt.setInt(1, nodeId);   
			ResultSet rs = stmt.executeQuery();
			rs.next();
			String nodeTypeStr = rs.getString(1);
			if(!rs.wasNull())
			{
				char nodeType = nodeTypeStr.charAt(0);
				if (nodeType == DbNodeEntry.NODE_TYPE_DELETED)
					nodeDeleted = true;
			}
			
			rs.close();
		}
		finally
		{
			try
			{
				stmt.close();
			}
			catch (Exception e)
			{
			}
		}
		
		return nodeDeleted;
	}
	
	/**
	 *  Determines if the passed InetAddress object represents an interface alias.
	 *  The interface is an alias if the IpAddrTable collected from it via SNMP
	 *  does not contain itself.
	 * 
	 * @param ipAddr	Address of interface to be tested
	 * @param snmpc		IfSnmpCollector object containing SNMP collected
	 * 			ifTable and ipAddrTable information.
	 * 
	 * @return TRUE if the provided IP address is an alias, FALSE otherwise.
	 */
	private boolean isInterfaceAlias(InetAddress ipAddr, IfSnmpCollector snmpc)
	{
		Category log = ThreadCategory.getInstance(getClass());
		
		// Sanity check...null parms?
		if (ipAddr == null || snmpc == null)
			throw new IllegalArgumentException("ipAddr and snmpc parms cannot be null.");
			
		// SNMP collection successful?
		if (snmpc.failed())
			return false;
			
		// Verify that SNMP collection contains ifTable and ipAddrTable entries
		IfTable ifTable = null;
		IpAddrTable ipAddrTable = null;
		
		if(snmpc.hasIfTable())
			ifTable = snmpc.getIfTable();
		
		if (snmpc.hasIpAddrTable())
			ipAddrTable = snmpc.getIpAddrTable();
		
		if (ifTable == null || ipAddrTable == null)
			return false;
			
		// Loop through the interface table entries until there are no more
		// entries or we've found a match
		boolean isAlias = true;
		Iterator iter = ifTable.getEntries().iterator();

		while(iter.hasNext())
		{
			IfTableEntry ifEntry = (IfTableEntry)iter.next();
				
			if (ifEntry.containsKey("ifIndex") != true) {
			    log.debug("isInterfaceAlias:  Breaking from loop");
			    break;
			}
			
			//
			// Get the list of IP addresses for the current index and
			// determine if the provided address is present. 
			//
			int ifIndex = -1;
	  
			SnmpInt32 snmpIfIndex = (SnmpInt32)ifEntry.get(IfTableEntry.IF_INDEX);
			if(snmpIfIndex != null)
				ifIndex = snmpIfIndex.getValue();

			List addrList = IpAddrTable.getIpAddresses(ipAddrTable.getEntries(), ifIndex);
			Iterator addrIter = addrList.iterator();
			while(addrIter.hasNext())
			{	
				InetAddress tmpAddr = (InetAddress)addrIter.next();
				
				// Compare temp address to the provided IP address...as soon as we find
				// a match we're done.
				if (tmpAddr != null && tmpAddr.getHostAddress().equals(ipAddr.getHostAddress()))
				{
					// Match found, break out of inner while loop
					isAlias = false;
					break;
				}
			}
			
			// If match found break out of outer while loop
			if (isAlias == false)
				break;
		} // end while
		
		return isAlias;
	}
	
        /**
         * This method is used to verify if each interface on a node stored in the database is in the specified
         * SNMP data collection.
	 *
         * @param ipInterfaces	the ipInterfaces on a node stored in the database
	 * @param snmpc		IfSnmpCollector object containing SNMP collected
	 * 			ipAddrTable information.
	 * 
	 * @return TRUE if each ipInterface is contained in the ipAddrTable of the specified SNMP collection.
         *
         */
        private boolean areDbInterfacesInSnmpCollection(DbIpInterfaceEntry[] dbInterfaces, IfSnmpCollector snmpc)
        {
		Category log = ThreadCategory.getInstance(getClass());
		
                // Sanity check...null parms?
		if (dbInterfaces == null || snmpc == null)
                {
			log.error("areDbInterfacesInSnmpCollection: empty dbInterfaces or IfSnmpCollector.");
			return false;
		}
                
		// SNMP collection successful?
		if (snmpc.failed())
		{
                        log.error("areDbInterfacesInSnmpCollection: Snmp Collector failed.");
			return false;
		}
                
		// Verify that SNMP collection contains ipAddrTable entries
		IpAddrTable ipAddrTable = null;
		
		if (snmpc.hasIpAddrTable())
			ipAddrTable = snmpc.getIpAddrTable();
		
		if ( ipAddrTable == null)
		{
                        log.error("areDbInterfacesInSnmpCollection: null ipAddrTable in the snmp collection");
			return false;
		}
                
                List ipAddrList = ipAddrTable.getIpAddresses(ipAddrTable.getEntries());
                
		// Loop through the interface table entries until there are no more
		// entries or we've found a match
		boolean isAlias = true;
                for (int i=0; i < dbInterfaces.length; i++)
                {
                        InetAddress ipaddr = dbInterfaces[i].getIfAddress();
                        Iterator iter = ipAddrList.iterator();
                        boolean found = false;
                        while (iter.hasNext())
                        {
                                InetAddress addr = (InetAddress)iter.next();
			        if (log.isDebugEnabled())
				        log.debug("areDbInterfacesInSnmpCollection: ipaddress in db: " + ipaddr.getHostAddress()
                                                + " ipaddress in ipAddrTable: " + addr.getHostAddress()); 
                                
                                if (ipaddr.getHostAddress().equals(addr.getHostAddress()))
                                {
                                        found = true;
			                if (log.isDebugEnabled())
				                log.debug("areDbInterfacesInSnmpCollection: found match for ipaddress: " 
                                                        + ipaddr.getHostAddress()); 
                                        break;
                                }
                        }
                        if (!found)
                        {
			        if (log.isDebugEnabled())
			                log.debug("areDbInterfacesInSnmpCollection: ipaddress : " + ipaddr.getHostAddress() 
                                                + " not in the snmp collection. Snmp collection is not usable.");
                                return false;
                        }
                }

                return true;
       }

       
	/**
	 * This is where all the work of the class is done.  
	 */
	public void run()
	{
		Category log = ThreadCategory.getInstance(getClass());

		//
		// perform rescan of the node
		//
		DbNodeEntry dbNodeEntry = null;
		
		// Get DbNodeEntry object which represents this node and
		// load it from the database
		try
		{
			dbNodeEntry = DbNodeEntry.get(m_scheduledNode.getNodeId());
			if (log.isDebugEnabled())
				log.debug("RescanProcessor: start rescaning node: " + m_scheduledNode.getNodeId());
		}
		catch (SQLException sqlE)
		{
			log.error("RescanProcessor: unable to load node info for nodeId " + m_scheduledNode.getNodeId() 
                                + " from the database.", sqlE);
			log.error("Rescan failed for node w/ nodeid " + m_scheduledNode.getNodeId());
			return;
		}
		
		// If this is a forced rescan then retrieve all the interfaces
		// associated with this node and perform collections against them.  
		// Otherwise, this is a regularly scheduled rescan, only the 
		// node's managed interfaces are to be retrieved and collected.
		// 
		DbIpInterfaceEntry[] dbInterfaces = null;
		
		if (m_forceRescan)
		{
			// Retrieve list of interfaces associated with this nodeID
			// from the database
			log.debug("retrieving all interfaces for node: " + m_scheduledNode.getNodeId());
			try
			{
				dbInterfaces = dbNodeEntry.getInterfaces();
			}
			catch (NullPointerException npE)
			{
				log.error("RescanProcessor: Null pointer when retrieving interfaces for node " 
                                        + m_scheduledNode.getNodeId(), npE);
				log.error("Forced rescan failed for node w/ nodeid " + m_scheduledNode.getNodeId());
				return;
			}
			catch (SQLException sqlE)
			{
				log.error("RescanProcessor: unable to load interface info for nodeId " + m_scheduledNode.getNodeId() 
                                        + " from the database.", sqlE);
				log.error("Forced rescan failed for node w/ nodeid " + m_scheduledNode.getNodeId());
				return;
			}
		}
		else
		{
			// Retrieve list of managed interfaces associated with this nodeID
			// from the database
			log.debug("retrieving managed interfaces for node: " + m_scheduledNode.getNodeId());
			try
			{
				dbInterfaces = dbNodeEntry.getManagedInterfaces();
			}
			catch (NullPointerException npE)
			{
				log.error("RescanProcessor: Null pointer when retrieving managed interfaces for node " 
                                        + m_scheduledNode.getNodeId(), npE);
				log.error("Rescan failed for node w/ nodeid " + m_scheduledNode.getNodeId());
				return;
			}
			catch (SQLException sqlE)
			{
				log.error("RescanProcessor: unable to load interface info for nodeId " 
                                        + m_scheduledNode.getNodeId() + " from the database.", sqlE);
				log.error("Rescan failed for node w/ nodeid " + m_scheduledNode.getNodeId());
				return;
			}
		}
			
		// Run collector for each retrieved interface and add result
		// to a collector map.
		Map collectorMap = new HashMap();
		
		IfSnmpCollector snmpc = null;
		boolean doSnmpCollection = true;
		Map snmpTargets = null;
		for (int i=0; i<dbInterfaces.length; i++)
		{
			InetAddress ifaddr = dbInterfaces[i].getIfAddress();
				
			// collect the information from the interface.  
			// NOTE: skip '127.*.*.*' and '0.0.0.0' addresses.
			if(ifaddr.getHostAddress().startsWith("127") || 
				ifaddr.getHostAddress().equals("0.0.0.0"))
			{
				continue;
			}

			// Any targets/interfaces found via SNMP have already
			// been probed so skip them.
			if (snmpTargets != null)
			{
				log.debug("checking snmp target map for interface " + ifaddr.getHostAddress());
				if (snmpTargets.get(ifaddr) != null)
				{
					if (log.isDebugEnabled())
						log.debug("skipping collection for " + ifaddr.getHostAddress() + " found via SNMP.");
					continue;
				}
				else
					log.debug("snmp target map does not contain interface " + ifaddr.getHostAddress());
			}
			
			if (log.isDebugEnabled())
				log.debug("running collection for " + ifaddr.getHostAddress());
			
			IfCollector collector = new IfCollector(ifaddr, doSnmpCollection);
			collector.run();
			
			// Only need to collect SNMP data from one of the
			// node's interfaces. 
			//
			if (doSnmpCollection)
			{
				snmpc = collector.getSnmpCollector();
				if (snmpc != null && !snmpc.failed())
				{
					// Got a successful SNMP collection from the node
                                        if (areDbInterfacesInSnmpCollection(dbInterfaces, snmpc))
                                        {
					        doSnmpCollection = false;
					        if (collector.hasAdditionalTargets())
						        snmpTargets = collector.getAdditionalTargets();
					
					        if (log.isDebugEnabled())
						        log.debug("SNMP data collected via " + ifaddr.getHostAddress());
                                        }
                                        else
                                        {
			                        if (log.isDebugEnabled())
				                        log.debug("SNMP data collected via " + ifaddr.getHostAddress()
                                                                + " is not right.");
                                        }
				}
			}

			if (log.isDebugEnabled())
				log.debug("collection completed for " + ifaddr.getHostAddress());
			collectorMap.put(ifaddr.getHostAddress(), collector);
		}

		// Update the database
		//
		Date now = null;
		Connection dbc = null;
		boolean updateCompleted = false;
		try
		{
			// Synchronize on the Capsd sync lock so we can check if 
			// the interface is already in the database and perform 
			// the necessary inserts in one atomic operation
			//	
			// The SuspectEventProcessor class is also synchronizing on this
			// lock prior to performing database inserts or updates.
			synchronized(Capsd.getDbSyncLock())
			{
				// Get database connection
				//
				dbc = DatabaseConnectionFactory.getInstance().getConnection();
				
				// There is a slight possibility that the node being rescanned has
				// been deleted (due to reparenting) by another thread between the
				// time this rescan was started and the database sync lock was
				// grabbed.  Verify that the current nodeid is still valid (ie, not 
				// deleted) before continuing.
				//
				if (!isNodeDeleted(dbc, m_scheduledNode.getNodeId()))
				{
					// Get old primary SNMP interface (if one exists)
					//
					InetAddress oldPrimarySnmpIf = SuspectEventProcessor.getPrimarySnmpInterfaceFromDb(dbc, dbNodeEntry);
						
					// Update interface information
					//
					now = new Date();  
					updateInterfaces(dbc, now, dbNodeEntry, collectorMap);
					
					// Now that all interfaces have been added to the database we
					// can update the 'primarySnmpInterface' field of the ipInterface
					// table.  Necessary because the IP address must already be in 
					// the database to evaluate against a filter rule.
					//
					// First create a list of eligible loopback interfaces.
					//
					List snmpLBAddresses = buildLBSnmpAddressList(collectorMap, snmpc);
                                        InetAddress newLBSnmpPrimaryIf = CollectdConfigFactory.getInstance().determinePrimarySnmpInterface(snmpLBAddresses);
					// Now create a list of all eligible interfaces. Choose loopback
					// if exists.

                                        List snmpAddresses = buildSnmpAddressList(collectorMap, snmpc);
                                        InetAddress newSnmpPrimaryIf = CollectdConfigFactory.getInstance().determinePrimarySnmpInterface(snmpAddresses);
                                        if (newLBSnmpPrimaryIf == null)
                                        {
                                                SuspectEventProcessor.setPrimarySnmpInterface(dbc, dbNodeEntry, newSnmpPrimaryIf, oldPrimarySnmpIf);
                                        }
                                        else
                                        {
						newSnmpPrimaryIf = newLBSnmpPrimaryIf;
                                                if(log.isDebugEnabled())
                                                        log.debug("SuspectEventProcessor: Loopback Address set as primary: " + newLBSnmpPrimaryIf);
                                                SuspectEventProcessor.setPrimarySnmpInterface(dbc, dbNodeEntry, newLBSnmpPrimaryIf, oldPrimarySnmpIf);
                                        }

					// Now that we've identified the new primary SNMP interface
					// we can determine if it is necessary to generate certain
					// SNMP data collection related events
					//
					generateSnmpDataCollectionEvents(dbNodeEntry, oldPrimarySnmpIf, newSnmpPrimaryIf);
					
					// Update the node table entry
					//
					DbNodeEntry updatedNodeEntry = updateNode(dbc, now, dbNodeEntry, newSnmpPrimaryIf, dbInterfaces, collectorMap);
					
					updateCompleted = true;
				}
			}

		} // end try
		catch(Throwable t)
		{
			log.error("Error updating records", t);
		}
		finally
		{
			// Finished with the database connection, close it.
			try
			{
				if (dbc != null)
					dbc.close();
			}
			catch(SQLException e)
			{
				log.error("Error closing connection", e);
			}
		}

		// Send events associcatd with the rescan
		//
		if (updateCompleted)
		{
			// Send all events created during rescan process to eventd
			//
			Iterator iter = m_eventList.iterator();
			while (iter.hasNext())
			{
				try
				{
					EventIpcManagerFactory.getInstance().getManager().sendNow((Event)iter.next());

				}
				catch(Throwable t)
				{
					log.warn("run: unexpected throwable exception caught during send to middleware", t);
				}
			}
		}
			
		// Update the schedule information for the rescanned node
		// 
		m_scheduledNode.setLastScanned(now);
		m_scheduledNode.setScheduled(false);
			
		log.debug("RescanProcessor for node w/ nodeid " + m_scheduledNode.getNodeId() + " completed.");
	} // end run
	
	/**
	 * Determines if any SNMP data collection related events need to 
	 * be generated based upon the results of the current rescan.  If
	 * necessary will generate one of the following events:
	 *     'reinitializePrimarySnmpInterface'
	 *     'primarySnmpInterfaceChanged'
	 * 
	 * @param nodeEntry	  DbNodeEntry object of the node being rescanned.
	 * @param oldPrimarySnmpIf  Previous primary SNMP interface (from the DB).
	 * @param primarySnmpIf   Primary SNMP interface as determined by the 
	 *                        current rescan.
	 */
	private void generateSnmpDataCollectionEvents(DbNodeEntry nodeEntry, InetAddress oldPrimarySnmpIf, InetAddress primarySnmpIf)
	{
		Category log = ThreadCategory.getInstance(getClass());
		
		// NOTE:  If SNMP service was not previously supported on this node
		//        then the 'oldPrimarySnmpIf' variable will be null.
		//        If this is the case then no need to generate primarySnmpInterfaceChanged
		// 	  event, the nodeGainedService event generated due to the addition
		//        of SNMP is sufficient.
		if (oldPrimarySnmpIf == null && primarySnmpIf != null)
		{
			if (log.isDebugEnabled())
				log.debug("generateSnmpDataCollectionEvents: looks like SNMP support was recently enabled on this node...");
		}
		
		// A PrimarySnmpInterfaceChanged event is generated if the scan
		// found a different primary SNMP interface than what is stored
		// in the database.  
		//
		else if ( oldPrimarySnmpIf != null && primarySnmpIf != null &&
			!oldPrimarySnmpIf.equals(primarySnmpIf) )
		{
			if (log.isDebugEnabled())
			{
				log.debug("generateSnmpDataCollectionEvents: primary SNMP interface has changed.  Was: " + 
					oldPrimarySnmpIf.getHostAddress() + " Is: " + 
					primarySnmpIf.getHostAddress());
			}
			
			createPrimarySnmpInterfaceChangedEvent(nodeEntry.getNodeId(), primarySnmpIf, oldPrimarySnmpIf);
		}
		
		// An interface map is built by the SNMP poller when the primary 
		// SNMP interface is initialized by the service monitor.  This map
		// is used to associate each interface on the node with its 
		// ifIndex and ifLabel for purposes of performing data collection 
		// and storage.  If an ifIndex has changed for one or more 
		// interfaces or if a new interface was added to the node then
		// the primary SNMP interface must be reinitialized so that this 
		// interface map can be rebuilt with the new information.
		else if (m_ifIndexOnNodeChangedFlag || m_snmpIfTableChangedFlag)
		{
			if (log.isDebugEnabled())
				log.debug("generateSnmpDataCollectionEvents: Generating reinitializeSnmpInterface event for interface " + primarySnmpIf.getHostAddress());
			createReinitializePrimarySnmpInterfaceEvent(nodeEntry.getNodeId(), primarySnmpIf);
		}
	}
		
	/**
	 * This method is responsible for generating a nodeLabelChanged event and
	 * adding it to the event list. 
	 *
	 * @param updatedEntry	Updated node entry object
	 * @param originalEntry	Original node entry object
	 */
	private void createNodeLabelChangedEvent(DbNodeEntry updatedEntry, DbNodeEntry originalEntry)
	{
		Category log = ThreadCategory.getInstance(getClass());
		
		if (log.isDebugEnabled())
			log.debug("createNodeLabelChangedEvent: nodeId: " + updatedEntry.getNodeId()  + 
				" oldLabel: '" + originalEntry.getLabel() +
				"' oldSource: '" + originalEntry.getLabelSource() +
				"' newLabel: '" + updatedEntry.getLabel() + 
				"' newLabelSource: '" + updatedEntry.getLabelSource() + "'");
		
		Event newEvent = new Event();
		
		newEvent.setUei(EventConstants.NODE_LABEL_CHANGED_EVENT_UEI);
		
		newEvent.setSource("OpenNMS.Capsd");
		
		newEvent.setNodeid(updatedEntry.getNodeId());
		
		newEvent.setHost(Capsd.getLocalHostAddress());
		
		newEvent.setTime(EventConstants.formatToString(new java.util.Date()));

		// Add appropriate parms
		Parms eventParms = new Parms();
		Parm eventParm = null;
		Value parmValue = null;
		
		if (originalEntry.getLabel() != null)
		{
			// Add old node label
			eventParm = new Parm();
			eventParm.setParmName(EventConstants.PARM_OLD_NODE_LABEL);
			parmValue = new Value();
			parmValue.setContent(originalEntry.getLabel());
			eventParm.setValue(parmValue);
			eventParms.addParm(eventParm);
			
			// Add old node label source
			eventParm = new Parm();
			eventParm.setParmName(EventConstants.PARM_OLD_NODE_LABEL_SOURCE);
			parmValue = new Value();
			parmValue.setContent(String.valueOf(originalEntry.getLabelSource()));
			eventParm.setValue(parmValue);
			eventParms.addParm(eventParm);
		}
		
		if (updatedEntry.getLabel() != null)
		{
			// Add new node label
			eventParm = new Parm();
			eventParm.setParmName(EventConstants.PARM_NEW_NODE_LABEL);
			parmValue = new Value();
			parmValue.setContent(updatedEntry.getLabel());
			eventParm.setValue(parmValue);
			eventParms.addParm(eventParm);
			
			// Add new node label source
			eventParm = new Parm();
			eventParm.setParmName(EventConstants.PARM_NEW_NODE_LABEL_SOURCE);
			parmValue = new Value();
			parmValue.setContent(String.valueOf(updatedEntry.getLabelSource()));
			eventParm.setValue(parmValue);
			eventParms.addParm(eventParm);
		}
		
		// Add Parms to the event
		newEvent.setParms(eventParms);
		
		// Add event to the list of events to be sent out.
		m_eventList.add(newEvent);
		
		if (log.isDebugEnabled())
			log.debug("createNodeLabelChangedEvent: successfully created nodeLabelChanged event for nodeid: " + updatedEntry.getNodeId());
	}
	
	/**
	 * This method is responsible for generating a nodeInfoChanged event and
	 * adding it to the event list. 
	 *
	 * @param updatedEntry	Updated node entry object
	 * @param originalEntry	Original node entry object
	 */
	private void createNodeInfoChangedEvent(DbNodeEntry updatedEntry, DbNodeEntry originalEntry)
	{
		Category log = ThreadCategory.getInstance(getClass());
		
		if (log.isDebugEnabled())
			log.debug("createNodeInfoChangedEvent: nodeId: " + updatedEntry.getNodeId());
		
		Event newEvent = new Event();
		
		newEvent.setUei(EventConstants.NODE_INFO_CHANGED_EVENT_UEI);
		
		newEvent.setSource("OpenNMS.Capsd");
		
		newEvent.setNodeid(updatedEntry.getNodeId());
		
		newEvent.setHost(Capsd.getLocalHostAddress());
		
		newEvent.setTime(EventConstants.formatToString(new java.util.Date()));

		// Add appropriate parms
		Parms eventParms = new Parms();
		Parm eventParm = null;
		Value parmValue = null;
		
		// SysOID						
		if (updatedEntry.getSystemOID() != null)
		{
			eventParm = new Parm();
			eventParm.setParmName(EventConstants.PARM_NODE_SYSOID);
			parmValue = new Value();
			parmValue.setContent(updatedEntry.getSystemOID());
			eventParm.setValue(parmValue);
			eventParms.addParm(eventParm);
		}
		
		// SysName						
		if (updatedEntry.getSystemName() != null)
		{
			eventParm = new Parm();
			eventParm.setParmName(EventConstants.PARM_NODE_SYSNAME);
			parmValue = new Value();
			parmValue.setContent(updatedEntry.getSystemName());
			eventParm.setValue(parmValue);
			eventParms.addParm(eventParm);
		}
		
		// SysDescription
		if (updatedEntry.getSystemDescription() != null)
		{
			// Add new node label
			eventParm = new Parm();
			eventParm.setParmName(EventConstants.PARM_NODE_SYSDESCRIPTION);
			parmValue = new Value();
			parmValue.setContent(updatedEntry.getSystemDescription());
			eventParm.setValue(parmValue);
			eventParms.addParm(eventParm);
		}
		
		// SysLocation
		if (updatedEntry.getSystemLocation() != null)
		{
			// Add new node label
			eventParm = new Parm();
			eventParm.setParmName(EventConstants.PARM_NODE_SYSLOCATION);
			parmValue = new Value();
			parmValue.setContent(updatedEntry.getSystemLocation());
			eventParm.setValue(parmValue);
			eventParms.addParm(eventParm);
		}
		
		// SysContact
		if (updatedEntry.getSystemContact() != null)
		{
			// Add new node label
			eventParm = new Parm();
			eventParm.setParmName(EventConstants.PARM_NODE_SYSCONTACT);
			parmValue = new Value();
			parmValue.setContent(updatedEntry.getSystemContact());
			eventParm.setValue(parmValue);
			eventParms.addParm(eventParm);
		}
		
		// NetBIOS name
		if (updatedEntry.getNetBIOSName() != null)
		{
			// Add new node label
			eventParm = new Parm();
			eventParm.setParmName(EventConstants.PARM_NODE_NETBIOS_NAME);
			parmValue = new Value();
			parmValue.setContent(updatedEntry.getNetBIOSName());
			eventParm.setValue(parmValue);
			eventParms.addParm(eventParm);
		}
		
		// Domain name
		if (updatedEntry.getDomainName() != null)
		{
			// Add new node label
			eventParm = new Parm();
			eventParm.setParmName(EventConstants.PARM_NODE_DOMAIN_NAME);
			parmValue = new Value();
			parmValue.setContent(updatedEntry.getDomainName());
			eventParm.setValue(parmValue);
			eventParms.addParm(eventParm);
		}

		// Operating System
		if (updatedEntry.getOS() != null)
		{
			// Add new node label
			eventParm = new Parm();
			eventParm.setParmName(EventConstants.PARM_NODE_OPERATING_SYSTEM);
			parmValue = new Value();
			parmValue.setContent(updatedEntry.getOS());
			eventParm.setValue(parmValue);
			eventParms.addParm(eventParm);
		}
		
		// Add Parms to the event
		newEvent.setParms(eventParms);
		
		/// Add event to the list of events to be sent out.
		m_eventList.add(newEvent);
		
		if (log.isDebugEnabled())
			log.debug("createNodeInfoChangedEvent: successfully created nodeInfoChanged event for nodeid: " + updatedEntry.getNodeId());
	}

	/**
	 * This method is responsible for generating a primarySnmpInterfaceChanged event and
	 * adding it to the event list. 
	 *
	 * @param nodeId	Nodeid of node being rescanned.
	 * @param newPrimaryIf  new primary SNMP interface address
	 * @param oldPrimaryIf  old primary SNMP interface address
	 */
	private void createPrimarySnmpInterfaceChangedEvent(int nodeId, 
							InetAddress newPrimaryIf, 
							InetAddress oldPrimaryIf)
	{
		Category log = ThreadCategory.getInstance(getClass());
		
		String oldPrimaryAddr = null;
		if (oldPrimaryIf != null)
			oldPrimaryAddr = oldPrimaryIf.getHostAddress();
		
		String newPrimaryAddr = null;
		if (newPrimaryIf != null)
			newPrimaryAddr = newPrimaryIf.getHostAddress();
			
		if (log.isDebugEnabled())
			log.debug("createPrimarySnmpInterfaceChangedEvent: nodeId: " + nodeId  + 
			"oldPrimarySnmpIf: '" + oldPrimaryAddr + 
			"' newPrimarySnmpIf: '" + newPrimaryAddr + "'");
		
		Event newEvent = new Event();
		
		newEvent.setUei(EventConstants.PRIMARY_SNMP_INTERFACE_CHANGED_EVENT_UEI);
		
		newEvent.setSource("OpenNMS.Capsd");
		
		newEvent.setNodeid(nodeId);
		
		newEvent.setInterface(newPrimaryAddr);
		
		newEvent.setHost(Capsd.getLocalHostAddress());
		
		newEvent.setService("SNMP");
		
		newEvent.setTime(EventConstants.formatToString(new java.util.Date()));

		// Add appropriate parms
		Parms eventParms = new Parms();
		Parm eventParm = null;
		Value parmValue = null;
		
		if (oldPrimaryAddr != null)
		{
			// Add old node label
			eventParm = new Parm();
			eventParm.setParmName(EventConstants.PARM_OLD_PRIMARY_SNMP_ADDRESS);
			parmValue = new Value();
			parmValue.setContent(oldPrimaryAddr);
			eventParm.setValue(parmValue);
			eventParms.addParm(eventParm);
		}
		
		if (newPrimaryAddr != null)
		{
			// Add new node label
			eventParm = new Parm();
			eventParm.setParmName(EventConstants.PARM_NEW_PRIMARY_SNMP_ADDRESS);
			parmValue = new Value();
			parmValue.setContent(newPrimaryAddr);
			eventParm.setValue(parmValue);
			eventParms.addParm(eventParm);
		}
		
		// Add Parms to the event
		newEvent.setParms(eventParms);
		
		// Add event to the list of events to be sent out.
		m_eventList.add(newEvent);
		
		if (log.isDebugEnabled())
			log.debug("createPrimarySnmpInterfaceChangedEvent: successfully created primarySnmpInterfaceChanged event for nodeid: " + nodeId);
	}
	
	/**
	 * This method is responsible for generating a interfaceIndexChanged event and
	 * adding it to the event list. 
	 *
	 * @param updatedEntry	updated IP interface database entry
	 * @param originalEntry	original IP interface database entry
	 */
	private void createInterfaceIndexChangedEvent(DbIpInterfaceEntry updatedEntry, DbIpInterfaceEntry originalEntry)
	{
		Category log = ThreadCategory.getInstance(getClass());
		
		if (log.isDebugEnabled())
			log.debug("createInterfaceIndexChangedEvent: nodeId: " + updatedEntry.getNodeId()  + 
				" oldIfIndex: " + originalEntry.getIfIndex() + 
				" newIfIndex: " + updatedEntry.getIfIndex());
		
		Event newEvent = new Event();
		
		newEvent.setUei(EventConstants.INTERFACE_INDEX_CHANGED_EVENT_UEI);
		
		newEvent.setSource("OpenNMS.Capsd");
		
		newEvent.setNodeid(updatedEntry.getNodeId());
		
		newEvent.setHost(Capsd.getLocalHostAddress());
		
		newEvent.setInterface(updatedEntry.getIfAddress().getHostAddress());
		
		newEvent.setTime(EventConstants.formatToString(new java.util.Date()));

		// Add appropriate parms
		Parms eventParms = new Parms();
		Parm eventParm = null;
		Value parmValue = null;
		
		// Add old interface index
		eventParm = new Parm();
		eventParm.setParmName(EventConstants.PARM_OLD_IFINDEX);
		parmValue = new Value();
		parmValue.setContent(String.valueOf(originalEntry.getIfIndex()));
		eventParm.setValue(parmValue);
		eventParms.addParm(eventParm);
		
		// Add new interface index
		eventParm = new Parm();
		eventParm.setParmName(EventConstants.PARM_NEW_IFINDEX);
		parmValue = new Value();
		parmValue.setContent(String.valueOf(updatedEntry.getIfIndex()));
		eventParm.setValue(parmValue);
		eventParms.addParm(eventParm);
		
		// Add Parms to the event
		newEvent.setParms(eventParms);
		
		// Add event to the list of events to be sent out.
		m_eventList.add(newEvent);
		
		if (log.isDebugEnabled())
			log.debug("createInterfaceIndexChangedEvent: successfully created interfaceIndexChanged event for nodeid: " + updatedEntry.getNodeId());
	}
	
	/**
	 * This method is responsible for generating an ipHostNameChanged event and
	 * adding it to the event list.
	 *
	 * @param updatedEntry	updated IP interface database entry
	 * @param originalEntry	original IP interface database entry
	 */
	private void createIpHostNameChangedEvent(DbIpInterfaceEntry updatedEntry, DbIpInterfaceEntry originalEntry)
	{
		Category log = ThreadCategory.getInstance(getClass());
		
		if (log.isDebugEnabled())
			log.debug("createIpHostNameChangedEvent: nodeId: " + updatedEntry.getNodeId()  + 
				" oldHostName: " + originalEntry.getHostname() + 
				" newHostName: " + updatedEntry.getHostname());
		
		Event newEvent = new Event();
		
		newEvent.setUei(EventConstants.INTERFACE_IP_HOSTNAME_CHANGED_EVENT_UEI);
		
		newEvent.setSource("OpenNMS.Capsd");
		
		newEvent.setNodeid(updatedEntry.getNodeId());
		
		newEvent.setHost(Capsd.getLocalHostAddress());
		
		newEvent.setInterface(updatedEntry.getIfAddress().getHostAddress());
		
		newEvent.setTime(EventConstants.formatToString(new java.util.Date()));

		// Add appropriate parms
		Parms eventParms = new Parms();
		Parm eventParm = null;
		Value parmValue = null;
		
		// Add old IP Hostname
		if (originalEntry.getHostname() != null)
		{
			eventParm = new Parm();
			eventParm.setParmName(EventConstants.PARM_OLD_IP_HOSTNAME);
			parmValue = new Value();
			parmValue.setContent(originalEntry.getHostname());
			eventParm.setValue(parmValue);
			eventParms.addParm(eventParm);
		}
		
		// Add new IP Hostname
		if (updatedEntry.getHostname() != null)
		{
			eventParm = new Parm();
			eventParm.setParmName(EventConstants.PARM_IP_HOSTNAME);
			parmValue = new Value();
			parmValue.setContent(updatedEntry.getHostname());
			eventParm.setValue(parmValue);
			eventParms.addParm(eventParm);
		}
		
		// Add Parms to the event
		newEvent.setParms(eventParms);
		
		// Add event to the list of events to be sent out.
		m_eventList.add(newEvent);
		
		if (log.isDebugEnabled())
			log.debug("createIpHostNameChangedEvent: successfully created ipHostNameChanged event for nodeid: " + updatedEntry.getNodeId());
	}
	
	/**
	 * This method is responsible for generating a interfaceReparented event and
	 * adding it to the event list. 
	 *
	 * @param newNode 	Entry of node under which the interface was added.
	 * @param oldNodeId 	Node identifier of node from which the interface was removed.
	 * @param reparentedIf 	Reparented interface
	 */
	private void createInterfaceReparentedEvent(DbNodeEntry newNode,
							int 	oldNodeId,
							InetAddress reparentedIf)
	{
		Category log = ThreadCategory.getInstance(getClass());
		
		if (log.isDebugEnabled())
			log.debug("createInterfaceReparentedEvent: ifAddr: " + reparentedIf.getHostAddress() + 
					" oldNodeId: " + oldNodeId +	" newNodeId: " + newNode.getNodeId());
		
		Event newEvent = new Event();
		
		newEvent.setUei(EventConstants.INTERFACE_REPARENTED_EVENT_UEI);
		
		newEvent.setSource("OpenNMS.Capsd");
		
		newEvent.setNodeid(newNode.getNodeId());
		
		newEvent.setHost(Capsd.getLocalHostAddress());
		
		newEvent.setInterface(reparentedIf.getHostAddress());
		
		newEvent.setTime(EventConstants.formatToString(new java.util.Date()));

		// Add appropriate parms
		Parms eventParms = new Parms();
		Parm eventParm = null;
		Value parmValue = null;
		
		// Add old node id
		eventParm = new Parm();
		eventParm.setParmName(EventConstants.PARM_OLD_NODEID);
		parmValue = new Value();
		parmValue.setContent(String.valueOf(oldNodeId));
		eventParm.setValue(parmValue);
		eventParms.addParm(eventParm);
		
		// Add new node id
		eventParm = new Parm();
		eventParm.setParmName(EventConstants.PARM_NEW_NODEID);
		parmValue = new Value();
		parmValue.setContent(String.valueOf(newNode.getNodeId()));
		eventParm.setValue(parmValue);
		eventParms.addParm(eventParm);
		
		// Add ip host name
		String hostname = reparentedIf.getHostName();
			
		eventParm = new Parm();
		eventParm.setParmName(EventConstants.PARM_IP_HOSTNAME);
		parmValue = new Value();
		parmValue.setContent(hostname);
		eventParm.setValue(parmValue);
		eventParms.addParm(eventParm);
		
		// Add node label and node label source
		if (newNode.getLabel() != null)
		{
			eventParm = new Parm();
			eventParm.setParmName(EventConstants.PARM_NODE_LABEL);
			parmValue = new Value();
			parmValue.setContent(newNode.getLabel());
			eventParm.setValue(parmValue);
			eventParms.addParm(eventParm);
			
			eventParm = new Parm();
			eventParm.setParmName(EventConstants.PARM_NODE_LABEL_SOURCE);
			parmValue = new Value();
			parmValue.setContent(String.valueOf(newNode.getLabelSource()));
			eventParm.setValue(parmValue);
			eventParms.addParm(eventParm);
		}
		
		// Add nodeSysName
		if (newNode.getSystemName() != null)
		{
			eventParm = new Parm();
			eventParm.setParmName(EventConstants.PARM_NODE_SYSNAME);
			parmValue = new Value();
			parmValue.setContent(newNode.getSystemName());
			eventParm.setValue(parmValue);
			eventParms.addParm(eventParm);
		}
			
		// Add nodeSysDescription
		if (newNode.getSystemDescription() != null)
		{
			eventParm = new Parm();
			eventParm.setParmName(EventConstants.PARM_NODE_SYSDESCRIPTION);
			parmValue = new Value();
			parmValue.setContent(newNode.getSystemDescription());
			eventParm.setValue(parmValue);
			eventParms.addParm(eventParm);
		}
		
		// Add Parms to the event
		newEvent.setParms(eventParms);
		
		// Add event to the list of events to be sent out.
		m_eventList.add(newEvent);
		
		if (log.isDebugEnabled())
			log.debug("createInterfaceReparentedEvent: successfully created interfaceReparented event for nodeid/interface: " + 
									newNode.getNodeId() + "/" + reparentedIf.getHostAddress());
	}
	
	/**
	 * This method is responsible for generating a duplicateNodeDeleted event and
	 * adding it to the event list. 
	 *
	 * @param deletedNode Entry of duplciate node which was deleted. 
	 */
	private void createDuplicateNodeDeletedEvent(DbNodeEntry deletedNode)
	{
		Category log = ThreadCategory.getInstance(getClass());
		
		if (log.isDebugEnabled())
			log.debug("createDuplicateNodeDeletedEvent: delete nodeid: " + deletedNode.getNodeId());
		
		Event newEvent = new Event();
		
		newEvent.setUei(EventConstants.DUP_NODE_DELETED_EVENT_UEI);
		
		newEvent.setSource("OpenNMS.Capsd");
		
		newEvent.setNodeid(deletedNode.getNodeId());
		
		newEvent.setHost(Capsd.getLocalHostAddress());
		
		newEvent.setTime(EventConstants.formatToString(new java.util.Date()));

		// Add event to the list of events to be sent out.
		m_eventList.add(newEvent);
		
		if (log.isDebugEnabled())
			log.debug("createDuplicateNodeDeletedEvent: successfully created duplicateNodeDeleted event for nodeid: " + deletedNode.getNodeId());
	}
	
	/**
	 * This method is responsible for generating a nodeGainedInterface event and
	 * adding it to the event list. 
	 *
	 * @param ifEntry  Entry of new interface.
	 */
	private void createNodeGainedInterfaceEvent(DbIpInterfaceEntry ifEntry)
	{
		Category log = ThreadCategory.getInstance(getClass());
		
		if (log.isDebugEnabled())
			log.debug("createNodeGainedInterfaceEvent: nodeId: " + ifEntry.getNodeId()  + 
				" interface: " + ifEntry.getIfAddress().getHostAddress());
		
		Event newEvent = new Event();
		
		newEvent.setUei(EventConstants.NODE_GAINED_INTERFACE_EVENT_UEI);
		
		newEvent.setSource("OpenNMS.Capsd");
		
		newEvent.setNodeid(ifEntry.getNodeId());
		
		newEvent.setHost(Capsd.getLocalHostAddress());
		
		newEvent.setInterface(ifEntry.getIfAddress().getHostAddress());
		
		newEvent.setTime(EventConstants.formatToString(new java.util.Date()));

		// Add appropriate parms
		Parms eventParms = new Parms();
		Parm eventParm = null;
		Value parmValue = null;
		
		// Add ip host name
		String hostname = null;
		if (ifEntry.getHostname() == null)
			hostname = "";
		else
			hostname = ifEntry.getHostname();
			
		eventParm = new Parm();
		eventParm.setParmName(EventConstants.PARM_IP_HOSTNAME);
		parmValue = new Value();
		parmValue.setContent(hostname);
		eventParm.setValue(parmValue);
		eventParms.addParm(eventParm);
		
		// Add discovery method
		eventParm = new Parm();
		eventParm.setParmName(EventConstants.PARM_METHOD);
		parmValue = new Value();
		parmValue.setContent("icmp");
		eventParm.setValue(parmValue);
		eventParms.addParm(eventParm);
		
		// Add Parms to the event
		newEvent.setParms(eventParms);
		
		// Add event to the list of events to be sent out.
		m_eventList.add(newEvent);
		
		if (log.isDebugEnabled())
			log.debug("createNodeGainedInterfaceEvent: successfully created nodeGainedInterface event for nodeid: " + ifEntry.getNodeId());
	}
	
	/**
	 * This method is responsible for generating a duplicateIpAddress event and
	 * adding it to the event list. 
	 *
	 * @param ifEntry  Entry of new interface.
	 */
	private void createDuplicateIpAddressEvent(DbIpInterfaceEntry ifEntry)
	{
		Category log = ThreadCategory.getInstance(getClass());
		
		if (log.isDebugEnabled())
			log.debug("createDuplicateIpAddressEvent: nodeId: " + ifEntry.getNodeId()  + 
				" interface: " + ifEntry.getIfAddress().getHostAddress());
		
		Event newEvent = new Event();
		
		newEvent.setUei(EventConstants.DUPLICATE_IPINTERFACE_EVENT_UEI);
		
		newEvent.setSource("OpenNMS.Capsd");
		
		newEvent.setNodeid(ifEntry.getNodeId());
		
		newEvent.setHost(Capsd.getLocalHostAddress());
		
		newEvent.setInterface(ifEntry.getIfAddress().getHostAddress());
		
		newEvent.setTime(EventConstants.formatToString(new java.util.Date()));

		// Add appropriate parms
		Parms eventParms = new Parms();
		Parm eventParm = null;
		Value parmValue = null;
		
		// Add ip host name
		String hostname = null;
		if (ifEntry.getHostname() == null)
			hostname = "";
		else
			hostname = ifEntry.getHostname();
			
		eventParm = new Parm();
		eventParm.setParmName(EventConstants.PARM_IP_HOSTNAME);
		parmValue = new Value();
		parmValue.setContent(hostname);
		eventParm.setValue(parmValue);
		eventParms.addParm(eventParm);
		
		// Add discovery method
		eventParm = new Parm();
		eventParm.setParmName(EventConstants.PARM_METHOD);
		parmValue = new Value();
		parmValue.setContent("icmp");
		eventParm.setValue(parmValue);
		eventParms.addParm(eventParm);
		
		// Add Parms to the event
		newEvent.setParms(eventParms);
		
		// Add event to the list of events to be sent out.
		m_eventList.add(newEvent);
		
		if (log.isDebugEnabled())
			log.debug("createDuplicateIpAddressEvent: successfully created duplicateIpAddress event for nodeid: " 
                                + ifEntry.getNodeId());
	}
	
	/**
	 * This method is responsible for generating a nodeGainedService event and
	 * adding it to the event list. 
	 *
	 * @param nodeEntry Entry of node which has gained a service
	 * @param ifEntry  Entry of interface which has gained a service
	 * @param svcName  Service name
	 */
	private void createNodeGainedServiceEvent(DbNodeEntry nodeEntry, DbIpInterfaceEntry ifEntry, String svcName)
	{
		Category log = ThreadCategory.getInstance(getClass());
		
		if (log.isDebugEnabled())
			log.debug("createNodeGainedServiceEvent: nodeId: " + ifEntry.getNodeId()  + 
				" interface: " + ifEntry.getIfAddress().getHostAddress() +
				" service: " + svcName);
		
		Event newEvent = new Event();
		
		newEvent.setUei(EventConstants.NODE_GAINED_SERVICE_EVENT_UEI);
		
		newEvent.setSource("OpenNMS.Capsd");
		
		newEvent.setNodeid(ifEntry.getNodeId());
		
		newEvent.setHost(Capsd.getLocalHostAddress());
		
		newEvent.setInterface(ifEntry.getIfAddress().getHostAddress());
		
		newEvent.setService(svcName);
		
		newEvent.setTime(EventConstants.formatToString(new java.util.Date()));

		// Add appropriate parms
		Parms eventParms = new Parms();
		Parm eventParm = null;
		Value parmValue = null;
		
		// Add ip host name
		String hostname = null;
		if (ifEntry.getHostname() == null)
			hostname = "";
		else
			hostname = ifEntry.getHostname();
			
		eventParm = new Parm();
		eventParm.setParmName(EventConstants.PARM_IP_HOSTNAME);
		parmValue = new Value();
		parmValue.setContent(hostname);
		eventParm.setValue(parmValue);
		eventParms.addParm(eventParm);
		
		// Add nodeSysName
		if (nodeEntry.getSystemName() != null)
		{
			eventParm = new Parm();
			eventParm.setParmName(EventConstants.PARM_NODE_SYSNAME);
			parmValue = new Value();
			parmValue.setContent(nodeEntry.getSystemName());
			eventParm.setValue(parmValue);
			eventParms.addParm(eventParm);
		}
			
		// Add nodeSysDescription
		if (nodeEntry.getSystemDescription() != null)
		{
			eventParm = new Parm();
			eventParm.setParmName(EventConstants.PARM_NODE_SYSDESCRIPTION);
			parmValue = new Value();
			parmValue.setContent(nodeEntry.getSystemDescription());
			eventParm.setValue(parmValue);
			eventParms.addParm(eventParm);
		}

		// Add Parms to the event
		newEvent.setParms(eventParms);
		
		// Add event to the list of events to be sent out.
		m_eventList.add(newEvent);
		
		if (log.isDebugEnabled())
			log.debug("createNodeGainedServiceEvent: successfully created nodeGainedService event for nodeid: " + ifEntry.getNodeId());
	}
	
	/**
	 * This method is responsible for generating a interfaceSupportsSNMPEvent event and
	 * adding it to the event list. 
	 *
	 * @param ifEntry  Entry of interface which has gained a service
	 */
	private void createInterfaceSupportsSNMPEvent(DbIpInterfaceEntry ifEntry)
	{
		Category log = ThreadCategory.getInstance(getClass());
		
		if (log.isDebugEnabled())
			log.debug("createInterfaceSupportsSNMPEvent: nodeId: " + ifEntry.getNodeId()  + 
				" interface: " + ifEntry.getIfAddress().getHostAddress());
		
		Event newEvent = new Event();
		
		newEvent.setUei(EventConstants.INTERFACE_SUPPORTS_SNMP_EVENT_UEI);
		
		newEvent.setSource("OpenNMS.Capsd");
		
		newEvent.setNodeid(ifEntry.getNodeId());
		
		newEvent.setHost(Capsd.getLocalHostAddress());
		
		newEvent.setInterface(ifEntry.getIfAddress().getHostAddress());
		
		newEvent.setTime(EventConstants.formatToString(new java.util.Date()));

		// Add event to the list of events to be sent out.
		m_eventList.add(newEvent);
		
		if (log.isDebugEnabled())
			log.debug("interfaceSupportsSNMPEvent: successfully created interfaceSupportsSNMPEvent event for nodeid: " + ifEntry.getNodeId());
	}
	
	/**
	 * This method is responsible for generating a reinitializePrimarySnmpInterface
	 * event and adding it to the event list. 
	 *
	 * @param nodeId  	Nodeid of node being rescanned.
	 * @param InetAddress 	Primary SNMP interface address.
	 */
	private void createReinitializePrimarySnmpInterfaceEvent(int nodeId, InetAddress primarySnmpIf)
	{
		Category log = ThreadCategory.getInstance(getClass());
		
		if (log.isDebugEnabled())
			log.debug("reinitializePrimarySnmpInterface: nodeId: " + nodeId  + 
				" interface: " + primarySnmpIf.getHostAddress());
		
		Event newEvent = new Event();
		
		newEvent.setUei(EventConstants.REINITIALIZE_PRIMARY_SNMP_INTERFACE_EVENT_UEI);
		
		newEvent.setSource("OpenNMS.Capsd");
		
		newEvent.setNodeid(nodeId);
		
		newEvent.setHost(Capsd.getLocalHostAddress());
		
		newEvent.setInterface(primarySnmpIf.getHostAddress());
		
		newEvent.setTime(EventConstants.formatToString(new java.util.Date()));

		// Add event to the list of events to be sent out.
		m_eventList.add(newEvent);
		
		if (log.isDebugEnabled())
			log.debug("createReinitializePrimarySnmpInterfaceEvent: successfully created reinitializePrimarySnmpInterface event for interface: " + primarySnmpIf.getHostAddress());
	}
	
} // end class
